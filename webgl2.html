<!DOCTYPE html>
<html>
<head>
    <title>WebGL Pixel Sorter</title>
    <style>
        html, body { margin: 0; padding: 0; overflow: hidden;  background-color: #000; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <script>
        // note: we've bound the position buffer to the vertex shader's "aVertexPosition" attribute
        // we've bound the offset texture to the fragment shader's "uOffsetTexture" uniform
        // and, critically, we've bound the offset texture to texture unit 0 (gl.TEXTURE0)
        // currently, the vertex shader does nothing, since we need a highly subdivided mesh to see the effect of the offset texture
        // so for now, we're using a simple "pass-through" vertex shader, which simply passes the vertex position to the fragment shader
        let then = 0;
        let canvas, gl;
        let positionBuffer;
        let offsetTexture;
        let shaderProgram, programInfo;
        //let positions = [];
        let pixelData;
        const bytesPerPixel = 4; // For RGBA format

        window.addEventListener("resize", ()=>{
            // onResize
            resizeCanvas();
            // todo: they sould grow and shrink dynamically...
            initializePositionsAndOffsetData();
        });

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        // two triangles that cover the entire screen
        // our display surface positions, not our inner "pixel" positions
        const output_surface_positions = [
            -1, -1,
            1, -1,
            -1, 1,
            -1, 1,
            1, -1,
            1, 1,
        ];

        // CPU position buffer mirrors to the GPU "offset texture":
        // these "positional" offsets are used as "Target" x, y values
        // and the fragment shader uses these "target" values, 
        // and lerps the "current" value _towards_ 
        // the "target" value over a parameterized duration of time
        // offsetTexture: [screenWidth x screenHeight] (rgba); where r = x offset, and g = y offset | b,a are unused for now

        // we artificially delay the sorting algo. to help visualize the sorting process
        // we then show how parallelism can be used to speed up the sorting process (bitonic sort) + realtime "accumulation" of the sorted values (similar to Raytracing stochastic accumulation)

        function initializePositionsAndOffsetData() {
            if(typeof positionBuffer == "undefined"){
                //throw new Error("positionBuffer is undefined");
                console.error("positionBuffer is undefined");
                return;
            }
            
            // Update buffers with new data
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, output_surface_positions, gl.DYNAMIC_DRAW);

            gl.bindTexture(gl.TEXTURE_2D, offsetTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);
            return;
            /*
            console.warn("Initializing output_surface_positions and pixel data");
            
            const numPixels = canvas.width * canvas.height;
            pixel_positions = new Float32Array(numPixels * 2); // x, y for each pixel
            pixelData = new Uint8Array(numPixels * bytesPerPixel); // RGBA for each pixel

            // Initialize position and pixel data
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const index = (y * canvas.width + x) * 2;
                    const pixelIndex = (y * canvas.width + x) * bytesPerPixel;

                    // Set position (x, y)
                    pixel_positions[index] = (x / canvas.width) * 2 - 1; // Convert to clip space
                    pixel_positions[index + 1] = (y / canvas.height) * 2 - 1; // Convert to clip space

                    // Initialize pixel data with random colors
                    pixelData[pixelIndex] = Math.floor(Math.random() * 256); // R
                    pixelData[pixelIndex + 1] = Math.floor(Math.random() * 256); // G
                    pixelData[pixelIndex + 2] = Math.floor(Math.random() * 256); // B
                    pixelData[pixelIndex + 3] = 255; // Alpha
                }
            }

            // Update buffers with new data
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);

            gl.bindTexture(gl.TEXTURE_2D, offsetTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);
            */
        }

        let swapped = false;
        /** 
         * return true if swapped
         * */
        // function applyBubbleSortStep() {
        //     console.warn("Applying bubble sort step");
        //     // Apply one step of the bubble sort algorithm
        //     swapped = false;
        //     const numPixels = canvas.width * canvas.height;
        //     for (let i = 0; i < numPixels - 1; i++) {
        //         const currentColor = pixelData.subarray(i * bytesPerPixel, (i + 1) * bytesPerPixel);
        //         const nextColor = pixelData.subarray((i + 1) * bytesPerPixel, (i + 2) * bytesPerPixel);

        //         // Compare colors based on the sum of RGB values
        //         if (currentColor[0] + currentColor[1] + currentColor[2] > nextColor[0] + nextColor[1] + nextColor[2]) {
        //             // Swap colors in pixel data
        //             [pixelData[i * bytesPerPixel], pixelData[(i + 1) * bytesPerPixel]] = [pixelData[(i + 1) * bytesPerPixel], pixelData[i * bytesPerPixel]];
        //             [pixelData[i * bytesPerPixel + 1], pixelData[(i + 1) * bytesPerPixel + 1]] = [pixelData[(i + 1) * bytesPerPixel + 1], pixelData[i * bytesPerPixel + 1]];
        //             [pixelData[i * bytesPerPixel + 2], pixelData[(i + 1) * bytesPerPixel + 2]] = [pixelData[(i + 1) * bytesPerPixel + 2], pixelData[i * bytesPerPixel + 2]];

        //             // Update offset data to reflect the swap
        //             const x1 = i % canvas.width;
        //             const y1 = Math.floor(i / canvas.width);
        //             const x2 = (i + 1) % canvas.width;
        //             const y2 = Math.floor((i + 1) / canvas.width);

        //             // offsetData[i * bytesPerPixel] = x2 % 256;
        //             // offsetData[i * bytesPerPixel + 1] = y2 % 256;
        //             // offsetData[(i + 1) * bytesPerPixel] = x1 % 256;
        //             // offsetData[(i + 1) * bytesPerPixel + 1] = y1 % 256;

        //             swapped = true;
        //         }
        //     }

        //     // Update the texture with the sorted pixel data
        //     gl.bindTexture(gl.TEXTURE_2D, offsetTexture);
        //     gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, canvas.width, canvas.height, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);

        //     return swapped;
        // }
        function onGLReady(){
            console.log("Initializing WebGL");

            // Create and bind the position buffer
            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            // go ahead and pop our initial data into the position buffer
            // we'll update it later
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(output_surface_positions), gl.DYNAMIC_DRAW);

            // Create and bind the offset texture
            offsetTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, offsetTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

            // @requires gl, canvas
            resizeCanvas();

            // @requires positionBuffer
            initializePositionsAndOffsetData();

            // for now we just pass-thru
            // later when we add sub-divided mesh, we'll need to use a vertex shader
            const vsSource = `
attribute vec4 aVertexPosition;
void main() {
    gl_Position = aVertexPosition;
}
            `;
            const fsSource = `
precision mediump float;
void main() {
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}
            `;

            shaderProgram = initShaderProgram(gl, vsSource, fsSource);
            // After initializing the shader program
            programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                },
                uniformLocations: {
                    uTime: gl.getUniformLocation(shaderProgram, 'uTime'),
                    // uOffsetTexture: gl.getUniformLocation(shaderProgram, 'uOffsetTexture'), // Add this line
                },
            };

            function initShaderProgram(gl, vsSource, fsSource) {
                console.warn('[Debug] initShaderProgram',{gl,vsSource,fsSource});
                const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
                const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

                const shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.linkProgram(shaderProgram);

                if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                    console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                    return null;
                }

                // if there are ANY gl errors, re-throw the error
                const error = gl.getError();
                if (error !== gl.NO_ERROR) {
                    //throw new Error('WebGL Error: ' + error);
                    console.error('WebGL Error: ', error);
                }

                return shaderProgram;
            }

            function loadShader(gl, type, source) {
                console.warn('loadShader',{gl,type,source})
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                // if there are ANY gl errors, re-throw the error
                const error = gl.getError();
                if (error !== gl.NO_ERROR) {
                    //throw new Error('WebGL Error: ' + error);
                    console.error('WebGL Error: ', error);
                }

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }

                return shader;
            }
        }
        // Draw the scene repeatedly
        function render(now) {
            now *= 0.001;  // convert to seconds
            const deltaTime = now - then;
            then = now;

            // apply one step every second
            // if (deltaTime > 1) {
            //     const swapped = applyBubbleSortStep();
            //     if (!swapped) {
            //         // If no swaps were made, the array is sorted
            //         console.log('Array sorted!');
            //     }
            // }

            drawScene(gl, programInfo, positionBuffer, deltaTime);

            requestAnimationFrame(render);
        }
        // draw scene
        function drawScene(gl, programInfo, positionBuffer, deltaTime) {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
            gl.clearDepth(1.0);                 // Clear everything
            gl.enable(gl.DEPTH_TEST);           // Enable depth testing
            gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

            // Clear the canvas
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Bind the position buffer.
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            // Tell WebGL how to pull out the positions from the 
            // positionBuffer into the vertexPosition attribute called "aVertexPosition"
            // note: it WAS reading rg as xy, but now we're going back to an array of float pairs
            {
                const numComponents = 2;  // pull out 2 values per iteration
                const type = gl.FLOAT;    // the data in the buffer is 32bit floats
                const normalize = false;  // don't normalize
                const stride = 0;         // how many bytes to get from one set to the next
                const offset = 0;         // how many bytes inside the buffer to start from
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexPosition,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                gl.enableVertexAttribArray(
                    programInfo.attribLocations.vertexPosition);
            }

            // Bind the offset texture to a texture unit
            //gl.activeTexture(gl.TEXTURE0);
            //gl.bindTexture(gl.TEXTURE_2D, offsetTexture);
            

            // Use our program when drawing
            gl.useProgram(programInfo.program);

            // Set the shader uniforms
            gl.uniform1f(programInfo.uniformLocations.uTime, deltaTime);
            //gl.uniform1i(programInfo.uniformLocations.uOffsetTexture, 0);

            {
                const offset = 0;
                const vertexCount = 6;
                gl.drawArrays(gl.TRIANGLES, offset, vertexCount);
            }
        }
        function onReady(){
            // WebGL context setup
            canvas = document.getElementById('glCanvas');
            gl = canvas.getContext('webgl');

            if (!gl) {
                //console.error('Unable to initialize WebGL. Your browser may not support it.');
                return;
            }
            // prepares:
            // positionBuffer, 
            onGLReady();            
            requestAnimationFrame(render);

            
        }
        document.addEventListener("DOMContentLoaded", onReady);

    </script>
</body>
</html>
