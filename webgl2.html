<!DOCTYPE html>
<html>
<head>
    <title>WebGL Pixel Sorter</title>
    <style>
        html, body { margin: 0; padding: 0; overflow: hidden;  background-color: #000; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <script>
        let then = 0;
        let canvas, gl;
        let positionBuffer;
        let offsetTexture;
        let shaderProgram, programInfo;
        let positions = [];
        let pixelData;
        const bytesPerPixel = 4; // For RGBA format

        window.addEventListener("resize", resizeCanvas);

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);

            initializePositionsAndOffsetData();
        }

        function initializePositionsAndOffsetData() {
            console.warn("Initializing positions and pixel data");
            
            const numPixels = canvas.width * canvas.height;
            positions = new Float32Array(numPixels * 2); // x, y for each pixel
            pixelData = new Uint8Array(numPixels * bytesPerPixel); // RGBA for each pixel

            // Initialize position and pixel data
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const index = (y * canvas.width + x) * 2;
                    const pixelIndex = (y * canvas.width + x) * bytesPerPixel;

                    // Set position (x, y)
                    positions[index] = (x / canvas.width) * 2 - 1; // Convert to clip space
                    positions[index + 1] = (y / canvas.height) * 2 - 1; // Convert to clip space

                    // Initialize pixel data with random colors
                    pixelData[pixelIndex] = Math.floor(Math.random() * 256); // R
                    pixelData[pixelIndex + 1] = Math.floor(Math.random() * 256); // G
                    pixelData[pixelIndex + 2] = Math.floor(Math.random() * 256); // B
                    pixelData[pixelIndex + 3] = 255; // Alpha
                }
            }

            // Update buffers with new data
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);

            gl.bindTexture(gl.TEXTURE_2D, offsetTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);
        }

        let swapped = false;
        function applyBubbleSortStep() {
            console.warn("Applying bubble sort step");
            // Apply one step of the bubble sort algorithm
            swapped = false;
            const numPixels = canvas.width * canvas.height;
            for (let i = 0; i < numPixels - 1; i++) {
                const currentColor = pixelData.subarray(i * bytesPerPixel, (i + 1) * bytesPerPixel);
                const nextColor = pixelData.subarray((i + 1) * bytesPerPixel, (i + 2) * bytesPerPixel);

                // Compare colors based on the sum of RGB values
                if (currentColor[0] + currentColor[1] + currentColor[2] > nextColor[0] + nextColor[1] + nextColor[2]) {
                    // Swap colors in pixel data
                    [pixelData[i * bytesPerPixel], pixelData[(i + 1) * bytesPerPixel]] = [pixelData[(i + 1) * bytesPerPixel], pixelData[i * bytesPerPixel]];
                    [pixelData[i * bytesPerPixel + 1], pixelData[(i + 1) * bytesPerPixel + 1]] = [pixelData[(i + 1) * bytesPerPixel + 1], pixelData[i * bytesPerPixel + 1]];
                    [pixelData[i * bytesPerPixel + 2], pixelData[(i + 1) * bytesPerPixel + 2]] = [pixelData[(i + 1) * bytesPerPixel + 2], pixelData[i * bytesPerPixel + 2]];

                    // Update offset data to reflect the swap
                    const x1 = i % canvas.width;
                    const y1 = Math.floor(i / canvas.width);
                    const x2 = (i + 1) % canvas.width;
                    const y2 = Math.floor((i + 1) / canvas.width);

                    // offsetData[i * bytesPerPixel] = x2 % 256;
                    // offsetData[i * bytesPerPixel + 1] = y2 % 256;
                    // offsetData[(i + 1) * bytesPerPixel] = x1 % 256;
                    // offsetData[(i + 1) * bytesPerPixel + 1] = y1 % 256;

                    swapped = true;
                }
            }

            // Update the texture with the sorted pixel data
            gl.bindTexture(gl.TEXTURE_2D, offsetTexture);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, canvas.width, canvas.height, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);

            return swapped;
        }
        function onGLReady(){
            console.log("Initializing WebGL");

            // Create and bind the position buffer
            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            // Create and bind the offset texture
            offsetTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, offsetTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

            resizeCanvas();

            const vsSource = `
                attribute vec4 aVertexPosition;
                varying vec2 vTextureCoord;
                void main() {
                    gl_Position = aVertexPosition;
                    vTextureCoord = aVertexPosition.xy * 0.5 + 0.5;
                }
            `;

            const fsSource = `
                precision mediump float;
                varying vec2 vTextureCoord;
                uniform sampler2D uOffsetTexture;
                void main() {
                    vec4 color = texture2D(uOffsetTexture, vTextureCoord);
                    gl_FragColor = color;
                }
            `;

            shaderProgram = initShaderProgram(gl, vsSource, fsSource);
            // After initializing the shader program
            programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                },
                uniformLocations: {
                    uTime: gl.getUniformLocation(shaderProgram, 'uTime'),
                    uOffsetTexture: gl.getUniformLocation(shaderProgram, 'uOffsetTexture'), // Add this line
                },
            };

            function initShaderProgram(gl, vsSource, fsSource) {
                console.warn('[Debug] initShaderProgram',{gl,vsSource,fsSource});
                const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
                const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

                const shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.linkProgram(shaderProgram);

                if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                    console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                    return null;
                }

                return shaderProgram;
            }

            function loadShader(gl, type, source) {
                console.warn('loadShader',{gl,type,source})
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }

                return shader;
            }
        }
        // Draw the scene repeatedly
        function render(now) {
            now *= 0.001;  // convert to seconds
            const deltaTime = now - then;
            then = now;

            // apply one step every second
            if (deltaTime > 1) {
                const swapped = applyBubbleSortStep();
                if (!swapped) {
                    // If no swaps were made, the array is sorted
                    console.log('Array sorted!');
                }
            }

            drawScene(gl, programInfo, positionBuffer, deltaTime);

            requestAnimationFrame(render);
        }
        // draw scene
        function drawScene(gl, programInfo, positionBuffer, deltaTime) {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
            gl.clearDepth(1.0);                 // Clear everything
            gl.enable(gl.DEPTH_TEST);           // Enable depth testing
            gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

            // Clear the canvas
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Bind the position buffer.
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            // Tell WebGL how to pull out the positions from the position
            // buffer into the vertexPosition attribute.
            {
                const numComponents = 2;  // pull out 2 values per iteration
                const type = gl.FLOAT;    // the data in the buffer is 32bit floats
                const normalize = false;  // don't normalize
                const stride = 0;         // how many bytes to get from one set to the next
                const offset = 0;         // how many bytes inside the buffer to start from
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexPosition,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                gl.enableVertexAttribArray(
                    programInfo.attribLocations.vertexPosition);
            }

            // Bind the offset texture to a texture unit
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, offsetTexture);
            

            // Use our program when drawing
            gl.useProgram(programInfo.program);

            // Set the shader uniforms
            gl.uniform1f(programInfo.uniformLocations.uTime, deltaTime);
            gl.uniform1i(programInfo.uniformLocations.uOffsetTexture, 0);

            {
                const offset = 0;
                const vertexCount = 6;
                gl.drawArrays(gl.TRIANGLES, offset, vertexCount);
            }
        }
        function onReady(){
            // WebGL context setup
            canvas = document.getElementById('glCanvas');
            gl = canvas.getContext('webgl');

            if (!gl) {
                //console.error('Unable to initialize WebGL. Your browser may not support it.');
                return;
            }
            onGLReady();            
            requestAnimationFrame(render);

            
        }
        document.addEventListener("DOMContentLoaded", onReady);

    </script>
</body>
</html>
