<!DOCTYPE html>
<!-- 
    > add bitonic sort to our todo list 
-->
<html>
<head>
    <title>WebGL Pixel Sorter</title>
    <style>
        html, body { margin: 0; padding: 0; overflow: hidden;  background-color: #000; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <script>
        // fsshader fragment shader source frag shader here fshader
        const fsSource = `
precision mediump float;
uniform vec2 uResolution;
uniform float uTime;
uniform sampler2D uOffsetTexture;
uniform sampler2D uBaseTexture;
uniform int uMode;
uniform int uPxDensity;

uniform int uSortOffset;
uniform int uSortStepSize;

vec2 corrected;
void main() {
    // adjust for pixel density
    corrected = gl_FragCoord.xy / (uResolution * float(uPxDensity));

    // if uSortOffset > 0, we need to check if _this_ pixel's corresponding index
    // falls within uSortStepSize worth of pixels as expressed in a 1D array of rgba values
    // if so, we need to return yellow
    // int numPixels = int(uResolution.x * uResolution.y);
    int correctedNumPixels = int(uResolution.x * uResolution.y) / uPxDensity;
    int correctedSortOffset = uSortOffset; // / uPxDensity;
    int correctedSortStepSize = uSortStepSize; // / uPxDensity;
    if(correctedSortOffset > 0){
        // we need to check if this pixel's corresponding index falls within the sort window
        // if so, we need to return yellow
        int correctedPixelIndex = int(corrected.y * uResolution.x + corrected.x);
        if(correctedPixelIndex >= correctedSortOffset && correctedPixelIndex < correctedSortOffset + correctedSortStepSize){
            gl_FragColor = vec4(1.0,1.0,0.0,1.0);
            return;
        }
    }
    
    if(uMode == 1){
        // default mode: use the offset texture's [r]ed channel to offset our uv/xy[x] lookup in the OPPPOSITE direction
        // and use offset texture's [g]reen channel to offset our uv/xy[y] lookup in the OPPPOSITE direction
        
        gl_FragColor = texture2D(uBaseTexture, corrected.x - vec2(texture2D(uOffsetTexture, corrected).r, corrected.y - texture2D(uOffsetTexture, corrected).g));
        // constrain r,g,b to 0.0 - 1.0
        gl_FragColor.r = clamp(gl_FragColor.r, 0.0, 1.0);
        gl_FragColor.g = clamp(gl_FragColor.g, 0.0, 1.0);
        gl_FragColor.b = clamp(gl_FragColor.b, 0.0, 1.0);
        // make sure our alpha channel is 1.0
        gl_FragColor.a = 1.0;
    }else if(uMode == 2){
        // debug sample offset texture
        gl_FragColor = texture2D(uOffsetTexture, corrected);

        // set the green channel to an average of the two
        gl_FragColor.g = 0.0; //(gl_FragColor.r + gl_FragColor.b) / 2.0;
        gl_FragColor.a = 1.0;

        // // 3. lerp from base texture towards "target" offset texture
        // gl_FragColor = mix(texture2D(uBaseTexture, corrected), texture2D(uOffsetTexture, corrected), 0.5);
        
        // apply purple tint
        // gl_FragColor = vec4(gl_FragColor.rgb + vec3(0.5,0,0.5), 1.0);
    }else{
        // fallback mode
        // debug sample unmodified base texture
        gl_FragColor = texture2D(uBaseTexture, corrected);    
    }
}
        `;
        
        // note: we've bound the outputSurfacePositionBuffer to the vertex shader's "aVertexPosition" attribute
        // we've bound the offset texture to the fragment shader's "uOffsetTexture" uniform
        // and, critically, we've bound the offset texture to texture unit 0 (gl.TEXTURE0)
        // currently, the vertex shader does nothing, since we need a highly subdivided mesh to see the effect of the offset texture
        // so for now, we're using a simple "pass-through" vertex shader, which simply passes the vertex position to the fragment shader

        let frameCount = 0;
        let seed = 0;
        let MODE = 1;
        let _pixel_density = 4; //6 // larger = LARGER pixels, smaller = smaller (FASTER, LOWER REZ), 1:1 pixel ratio (SLOWER, HIGH REZ)
        Object.defineProperty(window, "pixel_density", {
            get: function(){
                return _pixel_density;
            },
            set: function(value){
                _pixel_density = value;
                resizeCanvas();
            }
        });
        Object.defineProperty(window, "MAX_SORT_STEP_SIZE", {
            get: function(){
                return 1e5 * 4; // Math.floor(canvas.width / pixel_density) * Math.floor(canvas.height / pixel_density);
            }
        })

        let then = 0;
        let canvas, gl;
        let outputSurfacePositionBuffer;
        let offsetTexture, baseTexture;
        let shaderProgram, programInfo;
        let pixel_positions = [];
        let pixelData, originalPixelData, latestPixelDataSnapshot;
        const bytesPerPixel = 4; // For RGBA format

        window.addEventListener("resize", ()=>{
            // onResize
            resizeCanvas();
            // todo: they sould grow and shrink dynamically...
            initializePositionsAndOffsetData();
        });

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            fixedPixelsX = Math.floor(canvas.width/pixel_density);
            fixedPixelsY = Math.floor(canvas.height/pixel_density);
            window.DID_BIND_BASE_SINCE_RESIZE = false;
            if(gl){
                try{
                    gl.viewport(0, 0, canvas.width, canvas.height);
                    gl.uniform2f(programInfo.uniformLocations.uResolution, Math.floor(canvas.width/pixel_density), Math.floor(canvas.height/pixel_density));
                }catch(e){
                    console.error("Error resizing canvas",e);
                }
            }
        }

        // two triangles that cover the entire screen
        // our display surface positions, not our inner "pixel" positions
        const output_surface_positions = [
            -1, -1,
            1, -1,
            -1, 1,
            -1, 1,
            1, -1,
            1, 1,
        ];

        // CPU outputSurfacePositionBuffer (output_surface_positions) mirrors to the GPU "offset texture":
        // these "positional" offsets are used as "Target" x, y values
        // and the fragment shader uses these "target" values, 
        // and lerps the "current" value _towards_ 
        // the "target" value over a parameterized duration of time
        // offsetTexture: [screenWidth x screenHeight] (rgba); where r = x offset, and g = y offset | b,a are unused for now

        // we artificially delay the sorting algo. to help visualize the sorting process
        // we then show how parallelism can be used to speed up the sorting process (bitonic sort) + realtime "accumulation" of the sorted values (similar to Raytracing stochastic accumulation)
        let numPixels = 0;
        let fixedPixelsX,fixedPixelsY;
        function initializePositionsAndOffsetData() {
            // if(typeof outputSurfacePositionBuffer == "undefined"){
            //     //throw new Error("outputSurfacePositionBuffer is undefined");
            //     console.error("outputSurfacePositionBuffer is undefined");
            //     return;
            // }
            
            // Update buffers with new data
            gl.bindBuffer(gl.ARRAY_BUFFER, outputSurfacePositionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, output_surface_positions, gl.DYNAMIC_DRAW);
            
            //console.warn("Initializing output_surface_positions and pixel data");

            
            
            numPixels = canvas.width * canvas.height;
            numPixels = Math.floor(numPixels / pixel_density);

            // error if not divisible by 4
            // if(numPixels % 4 !== 0){
            //     console.error("numPixels must be divisible by 4");
            //     return;
            // }
            // // error if not divisible by 2
            // if(numPixels % 2 !== 0){
            //     console.error("numPixels must be divisible by 2");
            //     return;
            // }

            pixel_positions = new Float32Array(numPixels * 2); // x, y for each pixel
            if(typeof pixelData === "undefined" || pixelData.length !== numPixels * bytesPerPixel){
                pixelData = new Uint8Array(numPixels * bytesPerPixel); // RGBA for each pixel

                // Initialize position and pixel data
                for (let y = 0; y < fixedPixelsY; y++) {
                    for (let x = 0; x < fixedPixelsX; x++) {
                        const index = (y * fixedPixelsX + x) * 2;
                        const pixelIndex = (y * fixedPixelsX + x) * bytesPerPixel;

                        // Set position (x, y)
                        pixel_positions[index] = (x / fixedPixelsX) * 2 - 1; // Convert to clip space
                        pixel_positions[index + 1] = (y / fixedPixelsY) * 2 - 1; // Convert to clip space

                        // Initialize pixel data with random colors
                        pixelData[pixelIndex] = Math.floor(Math.random() * 256); // R
                        pixelData[pixelIndex + 1] = Math.floor(Math.random() * 256); // G
                        pixelData[pixelIndex + 2] = Math.floor(Math.random() * 256); // B
                        pixelData[pixelIndex + 3] = 255; // Alpha
                    }
                }

                // Update buffers with new data
                // gl.bindBuffer(gl.ARRAY_BUFFER, pixelPositionsBuffer);
                // gl.bufferData(gl.ARRAY_BUFFER, pixel_positions, gl.DYNAMIC_DRAW);
    
                // bind the base texture to our initial pixel data ( a frozen snapshot of the initial state of the pixels for our lerping algo. to work with )
                gl.bindTexture(gl.TEXTURE_2D, baseTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, fixedPixelsX, fixedPixelsY, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);

            }
            resetOffsetTexture();

            // gl.bindTexture(gl.TEXTURE_2D, offsetTexture);

            // // Only use R and G channels, force A channel to 1
            // let offsetPixelData = pixelData.map((value, index) => {
            //     if (index === 3) {
            //         return 255; // full alpha
            //     }
            //     if (index === 2) {
            //         // average of R and G channels
            //         return (pixelData[index - 2] + pixelData[index - 1]) / 2;
            //     }
            //     return value;
            // });

            // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, fixedPixelsX, fixedPixelsY, 0, gl.RGBA, gl.UNSIGNED_BYTE, offsetPixelData);

            // Bind the output position buffer.
            gl.bindBuffer(gl.ARRAY_BUFFER, outputSurfacePositionBuffer);

            // Tell WebGL how to pull out the positions from the 
            // outputSurfacePositionBuffer into the vertexPosition attribute called "aVertexPosition"
            // note: it WAS reading rg as xy, but now we're going back to an array of float pairs
            {
                const numComponents = 2;  // pull out 2 values per iteration
                const type = gl.FLOAT;    // the data in the buffer is 32bit floats
                const normalize = false;  // don't normalize
                const stride = 0;         // how many bytes to get from one set to the next
                const offset = 0;         // how many bytes inside the buffer to start from
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexPosition,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                gl.enableVertexAttribArray(
                    programInfo.attribLocations.vertexPosition);
            }
        }

        function rgbToHsv(color){
            let r = color[0] / 255;
            let g = color[1] / 255;
            let b = color[2] / 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, v = max;
        
            let d = max - min;
            s = max == 0 ? 0 : d / max;
        
            if (max == min) {
                h = 0; // achromatic
            } else {
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
        
                h /= 6;
            }
        
            return [ h, s, v ];
        }

        let swapped = false;
        let DID_COMPLETE_SORT_SINCE_RESET = false;
        // current sorting offset
        // we pass this to our fragment shader 
        // so we can color the pixels that are currently being sorted
        // we also pass the window width, so we can color the pixels that are being compared
        let sortOffset = 0;
        window.sortStepSize = 10e5; //-1; //10e3; // Number of elements to sort per call, adjust as needed
        window.current_sortStepSize = window.sortStepSize;

        function resetOffsetTexture(){
            // reset offset texture to all 0s with 255 for alpha channel
            let zeros = new Uint8Array(fixedPixelsX * fixedPixelsY * bytesPerPixel);
            zeros = zeros.map((value, index) => {
                if (index === 3) {
                    return 255;
                }
                return value;
            });
            gl.bindTexture(gl.TEXTURE_2D, offsetTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, fixedPixelsX, fixedPixelsY, 0, gl.RGBA, gl.UNSIGNED_BYTE, zeros);
        }

        function newCheck(inner_i, currentColor, currentHSV, nextColor, nextHSV){
            let swapped = 0;
            let rankA = 0; // should we swap?
            let rankB = 0;
            rankA += currentHSV[0] > nextHSV[0] ? 1 : 0;
            rankB += currentHSV[0] < nextHSV[0] ? 1 : 0;

            rankA += currentHSV[1] > nextHSV[1] ? 1 : 0;
            rankB += currentHSV[1] < nextHSV[1] ? 1 : 0;

            rankA += currentHSV[2] > nextHSV[2] ? 1 : 0;
            rankB += currentHSV[2] < nextHSV[2] ? 1 : 0;

            rankA *= currentColor[3]/255; // account for alpha
            rankB *= nextColor[3]/255; // account for alpha

            //console.warn({rankA,rankB})

            if(rankA > rankB){
                // Swap colors in pixel data
                // [pixelData[inner_i * bytesPerPixel], pixelData[(inner_i + 1) * bytesPerPixel]] = [pixelData[(inner_i + 1) * bytesPerPixel], pixelData[inner_i * bytesPerPixel]];
                // [pixelData[inner_i * bytesPerPixel + 1], pixelData[(inner_i + 1) * bytesPerPixel + 1]] = [pixelData[(inner_i + 1) * bytesPerPixel + 1], pixelData[inner_i * bytesPerPixel + 1]];
                // [pixelData[inner_i * bytesPerPixel + 2], pixelData[(inner_i + 1) * bytesPerPixel + 2]] = [pixelData[(inner_i + 1) * bytesPerPixel + 2], pixelData[inner_i * bytesPerPixel + 2]];

                // NOTE: we don't swap, we're going to just update our pixelData using r to represent x offset, and g to represent y offset
                // we'll use the fragment shader to do the actual swapping
                // use our fixedPixelsX to account for row/column wrapping in this x/y calculation
                // we're visually how far the pixel has moved in terms of 1D array indexes, from it's original position to it's sorted position over time
                // we're going to be additively writing incremental changes as brightness adjustments to the offset texture
                // negative when we need to move left/up, positive when we need to move right/down
                // keeping in mind that we're accounting for going from 1D array space to 2D screen space as though the array were laid out in a rasterized pattern
                let x_offset = (inner_i + 1) % fixedPixelsX - inner_i % fixedPixelsX;
                let y_offset = Math.floor((inner_i + 1) / fixedPixelsX) - Math.floor(inner_i / fixedPixelsX);

                // make the offset a fixed value from 0 - 0.1
                x_offset = Math.sign(x_offset) * 0.1;
                y_offset = Math.sign(y_offset) * 0.1;

                // NOTE: given how array shifting works, we need to "write" an additive value to the offset texture for each intermediary pixel between the two pixels we're swapping
                // nice thing about this algo is, it's bitwise, so we can do it in parallel, AND there's no interviening pixels, so we don't have to account for it with our current sort algo
                pixelData[inner_i * bytesPerPixel] += x_offset;
                pixelData[inner_i * bytesPerPixel + 1] += y_offset;
                // empty green channel
                pixelData[inner_i * bytesPerPixel + 2] = 0;

                swapped = true;
            }
            return swapped;
        }

        let noSwapStreak = 0; // Track consecutive passes without swaps
        let prevDidSwap = false; // Track whether a swap occurred in the previous pass

        function finalSortPass() {
            sortStepSize = 1; // Set window size to minimum
            applyBubbleSortStep(); // Perform final sort pass
        }

        function isOverlookingPixels() {
            // Implement logic to check for consistently overlooked pixels
            // This could be a heuristic based on tracking which pixels haven't moved in several passes
            // or it could be a heuristic based on the number of pixels that have moved in the last pass
            
            return false; // Placeholder return
        }

        /** 
         * return true if swapped
         * */
        function applyBubbleSortStep() {
            //console.warn("Applying bubble sort step");
            // Apply one step of the bubble sort algorithm
            swapped = false;

            let crossedCycleBoundaryThisPass = false;

            const numPixels = fixedPixelsX * fixedPixelsY;
            let _sortStepSize = window.sortStepSize === -1 ? numPixels : window.sortStepSize;

            if (window.sortStepSize === -1) {
                let scale;
                if (numPixels < 1e5) {
                    // do multiple passes per frame when the image is small enough to fit into a single pass
                    scale = 1e5 / numPixels;
                } else {
                    // break into smaller chunks for large images
                    scale = numPixels / 1e5;
                }
                _sortStepSize = numPixels * scale; // Adjusting for pixel density
            }
            window.current_sortStepSize = _sortStepSize;
            
            // if _sortStepSize is > than the size of threads on our GPU, we need to break it up into multiple passes

            // Calculate the end of the current sorting window
            //const windowEnd = Math.min(sortOffset + _sortStepSize, numPixels - 1);
            const windowEnd = Math.max(0, sortOffset + _sortStepSize);

            // NOTE: there's a bug where if the offset is too large, we always wrap around before reaching the end of the base texture
            // we need to detect when this might happen and apply a correction to the window size to make sure that the whole texture is sorted
            // NOTE sortOffset is dynamic, and windowEnd is dynamic, so,
            // our heuristic to check if we might've overlooked pixels is defined as:
            // 

            // Update the sorting offset
            sortOffset += _sortStepSize;
            crossedCycleBoundaryThisPass = false;
            if (sortOffset >= numPixels) {
                crossedCycleBoundaryThisPass = true;
                // wrap around
                sortOffset = sortOffset % numPixels;
                // if we didnt swap this pass, 
                if(!prevDidSwap && !swapped){
                    // note we attribute multiple passes without swaps to the same cycle
                    noSwapStreak += Math.floor(((sortOffset % numPixels) / numPixels));
                }
            }

            for (let i = sortOffset; i < windowEnd - 1; i++) {
                let inner_i = i
                // if inner_i has gone out of bounds, we need to wrap it around
                if(inner_i >= numPixels){
                    inner_i = inner_i % numPixels;
                }
                const currentColor = pixelData.subarray(inner_i * bytesPerPixel, (inner_i + 1) * bytesPerPixel);
                const nextColor = pixelData.subarray((inner_i + 1) * bytesPerPixel, (inner_i + 2) * bytesPerPixel);


                // Compare colors based on the sum of RGB values
                if (currentColor[0] + currentColor[1] + currentColor[2] > nextColor[0] + nextColor[1] + nextColor[2]) {
                    // Swap colors in pixel data
                    [pixelData[inner_i * bytesPerPixel], pixelData[(inner_i + 1) * bytesPerPixel]] = [pixelData[(inner_i + 1) * bytesPerPixel], pixelData[inner_i * bytesPerPixel]];
                    [pixelData[inner_i * bytesPerPixel + 1], pixelData[(inner_i + 1) * bytesPerPixel + 1]] = [pixelData[(inner_i + 1) * bytesPerPixel + 1], pixelData[inner_i * bytesPerPixel + 1]];
                    [pixelData[inner_i * bytesPerPixel + 2], pixelData[(inner_i + 1) * bytesPerPixel + 2]] = [pixelData[(inner_i + 1) * bytesPerPixel + 2], pixelData[inner_i * bytesPerPixel + 2]];
                    swapped = true;
                }

                // convert to hsb , sort by hue, then value, then saturation
                // const currentHSV = rgbToHsv(currentColor);
                // const nextHSV = rgbToHsv(nextColor);
                // if(newCheck(inner_i, currentColor, currentHSV, nextColor, nextHSV)){
                //     swapped = true;
                // }
            }

            
            
            if (swapped) {
                // If a swap occurred, update the texture
                gl.bindTexture(gl.TEXTURE_2D, offsetTexture);
                // TODO: determine which bounding box DID change, and only update that region...
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, fixedPixelsX, fixedPixelsY, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);
            }

            // if we've somehow gone negative, flip positive and clamp to 0
            if(sortOffset < 0){
                throw new Error("sortOffset is negative");
            }

            prevDidSwap = swapped;

            return swapped;
        }
        // for now we just pass-thru
        // later when we add sub-divided mesh, we'll need to use a vertex shader
        const vsSource = `
attribute vec4 aVertexPosition;
void main() {
gl_Position = aVertexPosition;
}
        `;
        // samples from uBaseTexture and uOffsetTexture
        

        function initShaderProgram(gl, vsSource, fsSource) {
            console.warn('[Debug] initShaderProgram',{gl,vsSource,fsSource});
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }

            // if there are ANY gl errors, re-throw the error
            const error = gl.getError();
            if (error !== gl.NO_ERROR) {
                //throw new Error('WebGL Error: ' + error);
                console.error('WebGL Error: ', error);
            }

            return shaderProgram;
        }

        function loadShader(gl, type, source) {
            console.warn('loadShader',{gl,type,source})
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            // if there are ANY gl errors, re-throw the error
            const error = gl.getError();
            if (error !== gl.NO_ERROR) {
                //throw new Error('WebGL Error: ' + error);
                console.error('WebGL Error: ', error);
            }

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }
        
        function preloadShaders(){
            shaderProgram = initShaderProgram(gl, vsSource, fsSource);
            // After initializing the shader program
            programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                },
                uniformLocations: {
                    uMode: gl.getUniformLocation(shaderProgram, 'uMode'),
                    uTime: gl.getUniformLocation(shaderProgram, 'uTime'),
                    uPxDensity: gl.getUniformLocation(shaderProgram, 'uPxDensity'),
                    uResolution: gl.getUniformLocation(shaderProgram, 'uResolution'),
                    uOffsetTexture: gl.getUniformLocation(shaderProgram, 'uOffsetTexture'),
                    uBaseTexture: gl.getUniformLocation(shaderProgram, 'uBaseTexture'),
                    //uPixelPositions: gl.getUniformLocation(shaderProgram, 'uPixelPositions'),

                    uSortOffset: gl.getUniformLocation(shaderProgram, 'uSortOffset'),
                    uSortStepSize: gl.getUniformLocation(shaderProgram, 'uSortStepSize'),
                },
            };
        }

        function readyDisplaySurface(){
            // Create and bind the position buffer
            outputSurfacePositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, outputSurfacePositionBuffer);

            // go ahead and pop our initial data into the position buffer
            // we'll update it later
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(output_surface_positions), gl.DYNAMIC_DRAW);
        }

        function setupTextures(){
            // our initial pixel data
            // random noise for now, but we're going to add drag-and-drop later
            
            baseTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, baseTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            
            // Create and bind the offset texture
            // where we track position offsets for each pixel
            // from their unsorted initial positions to their sorted final positions
            offsetTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, offsetTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        }

        function onGLReady(){
            console.log("Initializing WebGL");

            preloadShaders();
            readyDisplaySurface();
            setupTextures();

            // @requires gl, canvas
            // faux "init" resize for updating to initial window size
            resizeCanvas();

            // @requires outputSurfacePositionBuffer
            initializePositionsAndOffsetData();

            
        }
        window.do_sort = 1;
        // Draw the scene repeatedly
        function render(now) {
            const deltaTime = now - then;
            then = now;

            //if (deltaTime > 0){//0.001) {
            if(do_sort){
                const swapped = applyBubbleSortStep();
                // if(
                //     noSwapStreak > 0 
                //     && !DID_COMPLETE_SORT_SINCE_RESET 
                //     && window.sortStepSize <= 2
                // ){
                //     DID_COMPLETE_SORT_SINCE_RESET = true;
                // }else{
                    if(
                        noSwapStreak > 0 // did we make it a full cycle with no swaps?
                        && !DID_COMPLETE_SORT_SINCE_RESET 
                        && window.sortStepSize > 2
                    ){
                        // let's start confirming by decreasing our sortStepSize
                        // reduce sortStepSize by factor of 2
                        window.sortStepSize = Math.max(2,parseInt(window.sortStepSize / 2));
                        console.warn('decreasing sortStepSize',window.sortStepSize);
                        if(window.sortStepSize <= 4){
                            // run our final sort pass
                            console.warn('final sort pass!')
                            DID_COMPLETE_SORT_SINCE_RESET = true;
                            finalSortPass();
                        }
                    }
                    if(
                        // if noSwapStreak reset, and we haven't completed the sort since the last reset
                        // and our current sortStepSize is less than our MAX_SORT_STEP_SIZE
                        // we increase the sortStepSize by factor of 2
                        noSwapStreak === 0 
                        && !DID_COMPLETE_SORT_SINCE_RESET 
                        && window.sortStepSize < window.MAX_SORT_STEP_SIZE
                    ){
                        // increase sortStepSize
                        window.sortStepSize = Math.min(window.MAX_SORT_STEP_SIZE,parseInt(window.sortStepSize * 2));
                        console.warn('increasing sortStepSize',window.sortStepSize);
                    }
                //}
            }
            //}

            drawScene(gl, programInfo, outputSurfacePositionBuffer, deltaTime);

            requestAnimationFrame(render);
        }
        document.addEventListener('click', (e)=>{
            MODE = (MODE + 1) % 3;
            console.log("MODE",MODE);

            if(!window.do_sort){
                window.do_sort = true;
                console.log("do_sort",window.do_sort);
            }
        });
        // draw scene
        function drawScene(gl, programInfo, deltaTime) {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
            gl.clearDepth(1.0);                 // Clear everything
            gl.enable(gl.DEPTH_TEST);           // Enable depth testing
            gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

            // Clear the canvas
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, offsetTexture);

            // Only use R and G channels, force A channel to 1
            pixelData = pixelData.map((value, index) => {
                if (index === 3) {
                    return 255;
                }
                if (index === 2) {
                    return 0;
                }
                return value;
            });

            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, fixedPixelsX, fixedPixelsY, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);

            if(typeof window.DID_BIND_BASE_SINCE_RESIZE == "undefined"||window.DID_BIND_BASE_SINCE_RESIZE === false){
                window.DID_BIND_BASE_SINCE_RESIZE = true;
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, baseTexture);
            }

            // Use our program when drawing
            gl.useProgram(programInfo.program);

            // Set the shader uniforms

            // sortOffset
            gl.uniform1i(programInfo.uniformLocations.uSortOffset, parseInt(sortOffset/numPixels));
            // sortStepSize
            gl.uniform1i(programInfo.uniformLocations.uSortStepSize, parseInt(sortStepSize));

            gl.uniform2f(programInfo.uniformLocations.uResolution, Math.floor(canvas.width/pixel_density), Math.floor(canvas.height/pixel_density));
            gl.uniform1f(programInfo.uniformLocations.uTime, performance.now() / 1000);
            gl.uniform1i(programInfo.uniformLocations.uPxDensity, pixel_density);
            gl.uniform1i(programInfo.uniformLocations.uMode, MODE);
            //gl.uniform1f(programInfo.uniformLocations.uPixelPositions, pixel_positions)
            gl.uniform1i(programInfo.uniformLocations.uOffsetTexture, 0);
            gl.uniform1i(programInfo.uniformLocations.uBaseTexture, 1);

            {
                const offset = 0;
                const vertexCount = 6;
                gl.drawArrays(gl.TRIANGLES, offset, vertexCount);
            }
        }

        let imageTex;
        function loadImageAsTexture(imageSource) {
            resetOffsetTexture();
            imageTex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, imageTex);

            // Set the parameters so we can render any size image.
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

            // Preload the texture with all green pixels
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 255, 0, 255]));

            // Create and load the image
            const image = new Image();
            image.onerror = function(e) { console.error("Error loading image", e); };
            image.onabort = function(e) { console.error("Error loading image", e); };
            image.onload = function() {
                handleImageLoad(image);
            };
            image.src = imageSource;
        }
        /*
        function loadImageAsTexture(url){
            // ./res/Screen-interface-design-Bill-Atkinson-Susan-Kare-1983.webp
            imageTex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, imageTex);
            
            // Set the parameters so we can render any size image.
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            // when texture area is small, bilinear filter the closest mipmap
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

            // when texture area is large, bilinear filter the first mipmap
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

            // preload the texture will all green pixels
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,new Uint8Array([0, 255, 0, 255]));

            // Upload the image into the texture.
            const level = 0;
            const internalFormat = gl.RGBA;
            const srcFormat = gl.RGBA;
            const srcType = gl.UNSIGNED_BYTE;

            const image = new Image();
            image.onerror = function(e) {
                console.error("Error loading image",e);
            };
            image.onabort = function(e) {
                console.error("Error loading image",e);
            };
            image.onload = function(e) {
                gl.bindTexture(gl.TEXTURE_2D, imageTex);
                gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, image);

                // load into baseTexture
                gl.bindTexture(gl.TEXTURE_2D, baseTexture);
                // base texture might have different dimensions, so we need to scale to FILL
                let croppedToFillPixels = new Uint8Array(fixedPixelsX * fixedPixelsY * bytesPerPixel);
                let croppedToFillPixelsIndex = 0;
                // Calculate offsets
                let offsetX = Math.max(0, (image.width - fixedPixelsX) / 2);
                let offsetY = Math.max(0, (image.height - fixedPixelsY) / 2);
                
                // let tempImagePixelData = new Uint8Array(image.width * image.height * bytesPerPixel);
                // for(let i = 0; i < tempImagePixelData.length; i++){
                //     tempImagePixelData[i] = image.data[i];
                // }


                console.warn("image.data.length",image?.data?.length,{image})
                for (let y = 0; y < fixedPixelsY; y++) {
                    for (let x = 0; x < fixedPixelsX; x++) {
                        // Adjust index to center the image
                        let originalX = x + offsetX;
                        let originalY = y + offsetY;
                        
                        let index;
                        if (originalX < image.width && originalY < image.height) {
                            // Pixel is within the bounds of the original image
                            index = (originalY * image.width + originalX) * 4;
                        } else {
                            // Pixel is outside the bounds, use a default value
                            index = -1;
                        }

                        if(!image.data) console.error("image.data is undefined");
                        if(!image.data.length) console.error("image.data.length is ",image.data.length);
                        

                        if (index >= 0) {
                            // Copy pixel data
                            croppedToFillPixels[croppedToFillPixelsIndex++] = image.data[index];
                            croppedToFillPixels[croppedToFillPixelsIndex++] = image.data[index + 1];
                            croppedToFillPixels[croppedToFillPixelsIndex++] = image.data[index + 2];
                            croppedToFillPixels[croppedToFillPixelsIndex++] = image.data[index + 3];
                        } else {
                            // Default pixel value (e.g., transparent)
                            croppedToFillPixels[croppedToFillPixelsIndex++] = 0;
                            croppedToFillPixels[croppedToFillPixelsIndex++] = 0;
                            croppedToFillPixels[croppedToFillPixelsIndex++] = 0;
                            croppedToFillPixels[croppedToFillPixelsIndex++] = 0;
                        }
                    }
                }
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, fixedPixelsX, fixedPixelsY, 0, gl.RGBA, gl.UNSIGNED_BYTE, croppedToFillPixels);
            };
            image.src = url;
        }
        */

        function handleImageLoad(image) {
            gl.bindTexture(gl.TEXTURE_2D, imageTex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

            handleImageLoadForBaseTex(image);

            DID_COMPLETE_SORT_SINCE_RESET = false;
        }

        function handleImageLoadForBaseTex(image) {
            baseTexWidth = fixedPixelsX;
            baseTexHeight = fixedPixelsY;
            // Calculate scale and translation
            let scaleX = baseTexWidth / image.width;
            let scaleY = baseTexHeight / image.height;
            let scale = Math.min(scaleX, scaleY); // Choose the smaller scale to fit the image within baseTex
            let translateX = (baseTexWidth - image.width * scale) / 2;
            let translateY = (baseTexHeight - image.height * scale) / 2;

            // Draw the image onto an off-screen canvas to get its pixel data
            let offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = image.width;
            offscreenCanvas.height = image.height;
            let ctx = offscreenCanvas.getContext('2d');
            ctx.drawImage(image, 0, 0);
            let imageData = ctx.getImageData(0, 0, image.width, image.height);

            // // check if image data is all 0s...
            // let allZero = true;
            // for(let i = 0; i < imageData.data.length; i++){
            //     if(imageData.data[i] !== 0){
            //         allZero = false;
            //         console.warn('non-zero pixel data',i,imageData.data[i]);
            //         break;
            //     }
            // }
            // if(allZero){
            //     throw new Error("Image data is all 0s");
            // }
            // let countNonzero = 0;
            // // jump in steps of four, ignore rgb if alpha is lower than 1
            // for(let i = 0; i < imageData.data.length; i+=4){
            //     if(imageData.data[i+3] > 0){
            //         // only count if at least 1 component is non-zero
            //         if(imageData.data[i] > 0 || imageData.data[i+1] > 0 || imageData.data[i+2] > 0){
            //             countNonzero++;
            //         }
            //     }
            // }
            // console.warn('countNonzero',countNonzero/(imageData.data.length/4));

            // Create a new pixel array for baseTex
            let baseTexPixels = new Uint8Array(baseTexWidth * baseTexHeight * 4); // Assuming RGBA

            // Copy pixels with scaling and translation
            for (let y = 0; y < baseTexHeight; y++) {
                for (let x = 0; x < baseTexWidth; x++) {
                    let sourceX = Math.floor((x - translateX) / scale);
                    let sourceY = Math.floor((y - translateY) / scale);

                    // invert y axis
                    sourceY = image.height - sourceY;

                    let baseIndex = (y * baseTexWidth + x) * 4;
                    if (sourceX >= 0 && sourceX < image.width && sourceY >= 0 && sourceY < image.height) {
                        let sourceIndex = (sourceY * image.width + sourceX) * 4;
                        baseTexPixels[baseIndex] = imageData.data[sourceIndex];       // R
                        baseTexPixels[baseIndex + 1] = imageData.data[sourceIndex + 1]; // G
                        baseTexPixels[baseIndex + 2] = imageData.data[sourceIndex + 2]; // B
                        baseTexPixels[baseIndex + 3] = imageData.data[sourceIndex + 3]; // A
                    } else {
                        // Fill with a default color or transparent
                        baseTexPixels[baseIndex] = 0;     // R
                        baseTexPixels[baseIndex + 1] = 0; // G
                        baseTexPixels[baseIndex + 2] = 0; // B
                        baseTexPixels[baseIndex + 3] = 0; // A
                    }
                }
            }

            // overwrite pixelData array with baseTexPixels
            pixelData = baseTexPixels;

            // Bind to baseTex and update its texture
            gl.bindTexture(gl.TEXTURE_2D, baseTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, baseTexWidth, baseTexHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, baseTexPixels);

            //console.warn('loaded number of pixels',baseTexPixels.length/4, baseTexPixels);
            
        }


        function onImageDrop(event) {
            // Handle image drop, load the image into baseTexture
            event.preventDefault();

            try {
                const file = event.dataTransfer.files[0];
                const reader = new FileReader();
                reader.onload = function(event) {
                    loadImageAsTexture(event.target.result); // Use loadImageAsTexture function
                    do_sort = true
                    MODE = 1;
                };
                reader.readAsDataURL(file);
            } catch (e) {
                console.error('Error loading dropped image', e);
            }
        }
        function onReady(){
            
            
            // WebGL context setup
            canvas = document.getElementById('glCanvas');
            canvas.addEventListener("drop", onImageDrop);
            canvas.addEventListener("dragover", function(event) { event.preventDefault(); });
            gl = canvas.getContext('webgl');

            if (!gl) {
                //console.error('Unable to initialize WebGL. Your browser may not support it.');
                return;
            }
            // prepares:
            // outputSurfacePositionBuffer, 
            onGLReady();      
            
            loadImageAsTexture("./res/Screen-interface-design-Bill-Atkinson-Susan-Kare-1983.webp");
            

            requestAnimationFrame(render);

            
        }
        document.addEventListener("DOMContentLoaded", onReady);

    </script>
</body>
</html>
