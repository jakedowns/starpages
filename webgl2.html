<!DOCTYPE html>
<!-- 
    > add bitonic sort to our todo list 
-->
<html>
<head>
    <title>WebGL Pixel Sorter</title>
    <style>
        html, body { margin: 0; padding: 0; overflow: hidden;  background-color: #000; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <script>
        const fsSource = `
precision mediump float;
uniform vec2 uResolution;
uniform float uTime;
uniform sampler2D uOffsetTexture;
uniform sampler2D uBaseTexture;
uniform int uMode;
uniform int uPxDensity;
vec2 corrected;
void main() {
    // adjust for pixel density
    corrected = gl_FragCoord.xy / (uResolution * float(uPxDensity));
    
    if(uMode == 0){
        // 0. sample base texture
        gl_FragColor = texture2D(uBaseTexture, corrected);
    }else if(uMode == 1){
        // 1. sample offset texture
        gl_FragColor = texture2D(uOffsetTexture, corrected);
    }else if(uMode == 2){
        // 2. vary color with time
        gl_FragColor = vec4(gl_FragColor.rgb + sin(uTime)*0.5, 1.0);
    }else if(uMode == 3){
        // 3. lerp from base texture towards "target" offset texture
        gl_FragColor = mix(texture2D(uBaseTexture, corrected), texture2D(uOffsetTexture, corrected), 0.5);
        // apply purple tint
        gl_FragColor = vec4(gl_FragColor.rgb + vec3(0.5,0,0.5), 1.0);
    }else{
        // 4. lerp from base texture towards "target" offset texture
        gl_FragColor = mix(texture2D(uBaseTexture, corrected), texture2D(uOffsetTexture, corrected), 0.5);
    }
}
        `;
        
        // note: we've bound the outputSurfacePositionBuffer to the vertex shader's "aVertexPosition" attribute
        // we've bound the offset texture to the fragment shader's "uOffsetTexture" uniform
        // and, critically, we've bound the offset texture to texture unit 0 (gl.TEXTURE0)
        // currently, the vertex shader does nothing, since we need a highly subdivided mesh to see the effect of the offset texture
        // so for now, we're using a simple "pass-through" vertex shader, which simply passes the vertex position to the fragment shader

        let frameCount = 0;
        let seed = 0;
        let MODE = 0;
        let pixel_density = 2; // scale for higher density

        let then = 0;
        let canvas, gl;
        let outputSurfacePositionBuffer;
        let offsetTexture, baseTexture;
        let shaderProgram, programInfo;
        let pixel_positions = [];
        let pixelData, originalPixelData, latestPixelDataSnapshot;
        const bytesPerPixel = 4; // For RGBA format

        window.addEventListener("resize", ()=>{
            // onResize
            resizeCanvas();
            // todo: they sould grow and shrink dynamically...
            initializePositionsAndOffsetData();
        });

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            fixedPixelsX = Math.floor(canvas.width/pixel_density);
            fixedPixelsY = Math.floor(canvas.height/pixel_density);
            window.DID_BIND_BASE_SINCE_RESIZE = false;
            if(gl){
                try{
                    gl.viewport(0, 0, canvas.width, canvas.height);
                    gl.uniform2f(programInfo.uniformLocations.uResolution, Math.floor(canvas.width/pixel_density), Math.floor(canvas.height/pixel_density));
                }catch(e){
                    console.error("Error resizing canvas",e);
                }
            }
        }

        // two triangles that cover the entire screen
        // our display surface positions, not our inner "pixel" positions
        const output_surface_positions = [
            -1, -1,
            1, -1,
            -1, 1,
            -1, 1,
            1, -1,
            1, 1,
        ];

        // CPU outputSurfacePositionBuffer (output_surface_positions) mirrors to the GPU "offset texture":
        // these "positional" offsets are used as "Target" x, y values
        // and the fragment shader uses these "target" values, 
        // and lerps the "current" value _towards_ 
        // the "target" value over a parameterized duration of time
        // offsetTexture: [screenWidth x screenHeight] (rgba); where r = x offset, and g = y offset | b,a are unused for now

        // we artificially delay the sorting algo. to help visualize the sorting process
        // we then show how parallelism can be used to speed up the sorting process (bitonic sort) + realtime "accumulation" of the sorted values (similar to Raytracing stochastic accumulation)
        let numPixels = 0;
        let fixedPixelsX,fixedPixelsY;
        function initializePositionsAndOffsetData() {
            if(typeof outputSurfacePositionBuffer == "undefined"){
                //throw new Error("outputSurfacePositionBuffer is undefined");
                console.error("outputSurfacePositionBuffer is undefined");
                return;
            }
            
            // Update buffers with new data
            gl.bindBuffer(gl.ARRAY_BUFFER, outputSurfacePositionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, output_surface_positions, gl.DYNAMIC_DRAW);
            
            //console.warn("Initializing output_surface_positions and pixel data");

            
            
            numPixels = canvas.width * canvas.height;
            numPixels = Math.floor(numPixels / pixel_density);

            // error if not divisible by 4
            // if(numPixels % 4 !== 0){
            //     console.error("numPixels must be divisible by 4");
            //     return;
            // }
            // // error if not divisible by 2
            // if(numPixels % 2 !== 0){
            //     console.error("numPixels must be divisible by 2");
            //     return;
            // }

            pixel_positions = new Float32Array(numPixels * 2); // x, y for each pixel
            pixelData = new Uint8Array(numPixels * bytesPerPixel); // RGBA for each pixel

            // Initialize position and pixel data
            for (let y = 0; y < fixedPixelsY; y++) {
                for (let x = 0; x < fixedPixelsX; x++) {
                    const index = (y * fixedPixelsX + x) * 2;
                    const pixelIndex = (y * fixedPixelsX + x) * bytesPerPixel;

                    // Set position (x, y)
                    pixel_positions[index] = (x / fixedPixelsX) * 2 - 1; // Convert to clip space
                    pixel_positions[index + 1] = (y / fixedPixelsY) * 2 - 1; // Convert to clip space

                    // Initialize pixel data with random colors
                    pixelData[pixelIndex] = Math.floor(Math.random() * 256); // R
                    pixelData[pixelIndex + 1] = Math.floor(Math.random() * 256); // G
                    pixelData[pixelIndex + 2] = Math.floor(Math.random() * 256); // B
                    pixelData[pixelIndex + 3] = 255; // Alpha
                }
            }

            // Update buffers with new data
            // gl.bindBuffer(gl.ARRAY_BUFFER, pixelPositionsBuffer);
            // gl.bufferData(gl.ARRAY_BUFFER, pixel_positions, gl.DYNAMIC_DRAW);

            // bind the base texture to our initial pixel data ( a frozen snapshot of the initial state of the pixels for our lerping algo. to work with )
            gl.bindTexture(gl.TEXTURE_2D, baseTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, fixedPixelsX, fixedPixelsY, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);

            gl.bindTexture(gl.TEXTURE_2D, offsetTexture);

            // Only use R and G channels, force A channel to 1
            let offsetPixelData = pixelData.map((value, index) => {
                if (index === 3) {
                    return 255; // full alpha
                }
                if (index === 2) {
                    // average of R and G channels
                    return (pixelData[index - 2] + pixelData[index - 1]) / 2;
                }
                return value;
            });

            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, fixedPixelsX, fixedPixelsY, 0, gl.RGBA, gl.UNSIGNED_BYTE, offsetPixelData);

            // Bind the output position buffer.
            gl.bindBuffer(gl.ARRAY_BUFFER, outputSurfacePositionBuffer);

            // Tell WebGL how to pull out the positions from the 
            // outputSurfacePositionBuffer into the vertexPosition attribute called "aVertexPosition"
            // note: it WAS reading rg as xy, but now we're going back to an array of float pairs
            {
                const numComponents = 2;  // pull out 2 values per iteration
                const type = gl.FLOAT;    // the data in the buffer is 32bit floats
                const normalize = false;  // don't normalize
                const stride = 0;         // how many bytes to get from one set to the next
                const offset = 0;         // how many bytes inside the buffer to start from
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexPosition,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                gl.enableVertexAttribArray(
                    programInfo.attribLocations.vertexPosition);
            }
        }

        let swapped = false;
        let sortOffset = 0;
        let sortWindowWidth; //10e3; // Number of elements to sort per call, adjust as needed
        /** 
         * return true if swapped
         * */
        function applyBubbleSortStep() {
            //console.warn("Applying bubble sort step");
            // Apply one step of the bubble sort algorithm
            swapped = false;

            const numPixels = fixedPixelsX * fixedPixelsY;
            sortWindowWidth = numPixels/2;

            // Calculate the end of the current sorting window
            const windowEnd = Math.min(sortOffset + sortWindowWidth, numPixels - 1);

            for (let i = sortOffset; i < windowEnd - 1; i++) {
                const currentColor = pixelData.subarray(i * bytesPerPixel, (i + 1) * bytesPerPixel);
                const nextColor = pixelData.subarray((i + 1) * bytesPerPixel, (i + 2) * bytesPerPixel);


                // Compare colors based on the sum of RGB values
                if (currentColor[0] + currentColor[1] + currentColor[2] > nextColor[0] + nextColor[1] + nextColor[2]) {
                    // Swap colors in pixel data
                    [pixelData[i * bytesPerPixel], pixelData[(i + 1) * bytesPerPixel]] = [pixelData[(i + 1) * bytesPerPixel], pixelData[i * bytesPerPixel]];
                    [pixelData[i * bytesPerPixel + 1], pixelData[(i + 1) * bytesPerPixel + 1]] = [pixelData[(i + 1) * bytesPerPixel + 1], pixelData[i * bytesPerPixel + 1]];
                    [pixelData[i * bytesPerPixel + 2], pixelData[(i + 1) * bytesPerPixel + 2]] = [pixelData[(i + 1) * bytesPerPixel + 2], pixelData[i * bytesPerPixel + 2]];
                    swapped = true;
                }
            }

            if (swapped) {
                // If a swap occurred, update the texture
                gl.bindTexture(gl.TEXTURE_2D, offsetTexture);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, fixedPixelsX, fixedPixelsY, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);
            }

            // Update the sorting offset
            sortOffset += sortWindowWidth;
            if (sortOffset >= numPixels - 1) {
                sortOffset = 0; // Reset the offset if we've reached the end
            }

            return swapped;
        }
        // for now we just pass-thru
        // later when we add sub-divided mesh, we'll need to use a vertex shader
        const vsSource = `
attribute vec4 aVertexPosition;
void main() {
gl_Position = aVertexPosition;
}
        `;
        // samples from uBaseTexture and uOffsetTexture
        

        function initShaderProgram(gl, vsSource, fsSource) {
            console.warn('[Debug] initShaderProgram',{gl,vsSource,fsSource});
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }

            // if there are ANY gl errors, re-throw the error
            const error = gl.getError();
            if (error !== gl.NO_ERROR) {
                //throw new Error('WebGL Error: ' + error);
                console.error('WebGL Error: ', error);
            }

            return shaderProgram;
        }

        function loadShader(gl, type, source) {
            console.warn('loadShader',{gl,type,source})
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            // if there are ANY gl errors, re-throw the error
            const error = gl.getError();
            if (error !== gl.NO_ERROR) {
                //throw new Error('WebGL Error: ' + error);
                console.error('WebGL Error: ', error);
            }

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }
        
        function preloadShaders(){
            shaderProgram = initShaderProgram(gl, vsSource, fsSource);
            // After initializing the shader program
            programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                },
                uniformLocations: {
                    uMode: gl.getUniformLocation(shaderProgram, 'uMode'),
                    uTime: gl.getUniformLocation(shaderProgram, 'uTime'),
                    uPxDensity: gl.getUniformLocation(shaderProgram, 'uPxDensity'),
                    uResolution: gl.getUniformLocation(shaderProgram, 'uResolution'),
                    uOffsetTexture: gl.getUniformLocation(shaderProgram, 'uOffsetTexture'),
                    uBaseTexture: gl.getUniformLocation(shaderProgram, 'uBaseTexture'),
                    //uPixelPositions: gl.getUniformLocation(shaderProgram, 'uPixelPositions'),
                },
            };
        }

        function readyDisplaySurface(){
            // Create and bind the position buffer
            outputSurfacePositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, outputSurfacePositionBuffer);

            // go ahead and pop our initial data into the position buffer
            // we'll update it later
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(output_surface_positions), gl.DYNAMIC_DRAW);
        }

        function setupTextures(){
            // our initial pixel data
            // random noise for now, but we're going to add drag-and-drop later
            
            baseTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, baseTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            
            // Create and bind the offset texture
            // where we track position offsets for each pixel
            // from their unsorted initial positions to their sorted final positions
            offsetTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, offsetTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        }

        function onGLReady(){
            console.log("Initializing WebGL");

            preloadShaders();
            readyDisplaySurface();
            setupTextures();

            // @requires gl, canvas
            // faux "init" resize for updating to initial window size
            resizeCanvas();

            // @requires outputSurfacePositionBuffer
            initializePositionsAndOffsetData();

            
        }
        // Draw the scene repeatedly
        function render(now) {
            const deltaTime = now - then;
            then = now;

            //if (deltaTime > 0){//0.001) {
                const swapped = applyBubbleSortStep();
                if (!swapped) {
                    // If no swaps were made, the array is sorted
                    //alert('Array sorted!');
                }
            //}

            drawScene(gl, programInfo, outputSurfacePositionBuffer, deltaTime);

            requestAnimationFrame(render);
        }
        document.addEventListener('click', (e)=>{
            MODE = (MODE + 1) % 5;
            console.log("MODE",MODE);
        });
        // draw scene
        function drawScene(gl, programInfo, deltaTime) {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
            gl.clearDepth(1.0);                 // Clear everything
            gl.enable(gl.DEPTH_TEST);           // Enable depth testing
            gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

            // Clear the canvas
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, offsetTexture);

            // Only use R and G channels, force A channel to 1
            pixelData = pixelData.map((value, index) => {
                if (index % 4 === 3) {
                    return 255;
                }
                if (index % 4 === 2) {
                    return 0;
                }
                return value;
            });

            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, fixedPixelsX, fixedPixelsY, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);

            if(typeof window.DID_BIND_BASE_SINCE_RESIZE == "undefined"||window.DID_BIND_BASE_SINCE_RESIZE === false){
                window.DID_BIND_BASE_SINCE_RESIZE = true;
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, baseTexture);
            }

            // Use our program when drawing
            gl.useProgram(programInfo.program);

            // Set the shader uniforms
            gl.uniform2f(programInfo.uniformLocations.uResolution, Math.floor(canvas.width/pixel_density), Math.floor(canvas.height/pixel_density));
            gl.uniform1f(programInfo.uniformLocations.uTime, performance.now() / 1000);
            gl.uniform1i(programInfo.uniformLocations.uPxDensity, pixel_density);
            gl.uniform1i(programInfo.uniformLocations.uMode, MODE);
            //gl.uniform1f(programInfo.uniformLocations.uPixelPositions, pixel_positions)
            gl.uniform1i(programInfo.uniformLocations.uOffsetTexture, 0);
            gl.uniform1i(programInfo.uniformLocations.uBaseTexture, 1);

            {
                const offset = 0;
                const vertexCount = 6;
                gl.drawArrays(gl.TRIANGLES, offset, vertexCount);
            }
        }
        function onImageDrop(event) {
            // Handle image drop, load the image into baseTexture
            event.preventDefault();

            try {
                const file = event.dataTransfer.files[0];
                const reader = new FileReader();
                reader.onload = function (event) {
                    const image = new Image();
                    image.onload = function () {
                        // Resize the canvas to match the image
                        canvas.width = image.width;
                        canvas.height = image.height;
                        fixedPixelsX = Math.floor(canvas.width/pixel_density);
                        fixedPixelsY = Math.floor(canvas.height/pixel_density);
                        initializePositionsAndOffsetData();

                        // Draw the image to the canvas
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(image, 0, 0);

                        // Get the image data
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                        // Copy the image data into pixelData
                        for (let i = 0; i < imageData.data.length; i++) {
                            pixelData[i] = imageData.data[i];
                        }

                        // Update the base texture
                        gl.bindTexture(gl.TEXTURE_2D, baseTexture);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, fixedPixelsX, fixedPixelsY, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);
                    };
                    image.src = event.target.result;
                };
                reader.readAsDataURL(file);
            } catch (e) {
                console.error('Error loading image', e);
            }
        }
        function onReady(){
            canvas.addEventListener("drop", onImageDrop);
            canvas.addEventListener("dragover", function(event) { event.preventDefault(); });


            // WebGL context setup
            canvas = document.getElementById('glCanvas');
            gl = canvas.getContext('webgl');

            if (!gl) {
                //console.error('Unable to initialize WebGL. Your browser may not support it.');
                return;
            }
            // prepares:
            // outputSurfacePositionBuffer, 
            onGLReady();            
            requestAnimationFrame(render);

            
        }
        document.addEventListener("DOMContentLoaded", onReady);

    </script>
</body>
</html>
