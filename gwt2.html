<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gherkin Test Manager</title>
    
    <script src="https://unpkg.com/vue@3.3.13"></script>
    <script src="https://unpkg.com/sortablejs@1.10.2"></script>
    <script src="https://unpkg.com/vuedraggable@4.0.1"></script>
    <!-- <script src="https://unpkg.com/vue-next-typeahead@0.0.2"></script> -->

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Open Sans', sans-serif;
            background-color: #111;
        }
        .clearfix {
            clear: both;
            overflow: auto;
        }
        input {
            color: #fff;
            background-color: #222;
        }
        .fixed-top {
            position: fixed;
            top: 0;
            left: 0;
            width: 33.3333%;
            background-color: #fff; /* Light theme */
            border-right: 1px solid #e5e7eb; /* Light theme border */
        }

        .left-panel {
            margin-top: /* Height of the .fixed-top element */;
            width: 33.3333%;
            height: calc(100% - /* Height of the .fixed-top element */);
            overflow-y: auto;
        }

        .main-content {
            width: 66.6667%;
            /* Other styles */
        }
        .caret-down::after {
            pointer-events: none;
            content: 'â–¼';
            position: absolute;
            right: 20px;
            top: 17px;
            z-index: 0;
        }
        .modal-underlay {
            pointer-events: none;
            background: rgba(0.5);
            transition: opacity 0.3s ease-in-out;
            opacity: 1;
        }
        .modal-underlay.fade-enter-active {
            transition: opacity 0.5s;
        }
        .modal-underlay.fade-enter-from {
            opacity: 0;
        }
        .modal-underlay.fade-enter-to {
            opacity: 1;
        }
        .modal-underlay.fade-leave-active {
            transition: opacity 0.5s;
        }
        .modal-underlay.fade-leave-from {
            opacity: 1;
        }
        .modal-underlay.fade-leave-to {
            opacity: 0;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 10;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgb(0,0,0);
            background-color: rgba(0,0,0,0.4);
            padding-top: 60px;
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        .typeahead-dropdown {
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            height: auto;
        }
    </style>
    <script>
        window.unwrap = function(obj){
            const seen = new WeakSet();
            return JSON.parse(JSON.stringify(obj, (key, value) => {
                if (typeof value === "object" && value !== null) {
                    if (seen.has(value)) {
                        return;
                    }
                    seen.add(value);
                }
                return value;
            }));
        }
    </script>
</head>
<body class="">

<div id="app" class="flex-row p-4 h-screen overflow-hidden">
    <feature-selector
        :selected-feature-index="selectedFeatureIndex"
        :selected-feature="selectedFeature"
        :features="features"
        :searchable-feature-names="searchableFeatureNames"
        :select-feature-index="selectFeatureIndex"
    ></feature-selector>
    <div class="flex">
        <div class="w-1/2">
            <scenario-list 
                :add-scenario="addScenario"
                :scenarios="scenarios"
                :select-scenario-index="selectScenarioIndex"
                :selected-scenario-index="selectedScenarioIndex"
                :end-drag="endDrag"
            ></scenario-list>
        </div>
        <div class="w-1/2 overflow-y-auto overflow-x-hidden">
            <scenario-details v-if="selectedScenario"
                :selected-scenario="selectedScenario"
                :selected-scenario-index="selectedScenarioIndex"
                :searchable-given-names="searchableGivenNames"
                :searchable-when-names="searchableWhenNames"
                :searchable-then-names="searchableThenNames"
            ></scenario-details>
        </div>
    </div>
    
    <transition name="fade">
        <div v-if="showingModal" class="modal-underlay z-99 fixed inset-0 backdrop-blur"></div>
    </transition>
    <delete-modal v-if="showDeleteModal" :delete-scenario="deleteScenario"></delete-modal>
</div>

<!-- Feature Selector is a type-head text field that doubles as a H1 header for the selected Feature as well as an input that allows you to fuzzy-search to switch the selected feature, and there's always a default option to "Create New Feature Named... %whatever the user was typing%" -->
<!-- FeatureSelector -->
<script type="text/x-template" id="feature-selector-template">
    <div class="w-full feature-selector z-11">
        <vue-typeahead
            placeholder="Feature Name..."
            :backingData="searchableFeatureNames"
            :items="features"
            :minChars="1"
            :show-dropdown-on-focus="true"
            :class="{'text-2xl font-bold mb-4': true}"
            :v-model="featureSelectorInput"
            @hit="onFeatureSelectorHit"
            @searching="onSearchingStateChanged"
            @filtered-options-updated="onFeatureSelectorResultsUpdated"
            @reset="onFeatureSelectorReset"
            @select="onFeatureSelectorSelect"
            @focus="onFocusIn"
            @blur="onFocusOut"
        ></vue-typeahead>
    </div>
</script>


<!-- ScenarioList -->
<script type="text/x-template" id="scenario-list-template">
    <div class="overflow-y-auto h-screen relative z-9">
        <div class="absolute w-full top-12">
            <input type="text" placeholder="New Scenario Name..." class="text-white w-full p-2 border rounded caret-down relative" v-model="newScenarioNameInput" @keyup.enter="addScenario" />
        </div>
        <!--
            "Actions" button group 
            > Run All Scenarios
            > Stop All Scenarios
            a tailwind-styled, bootstrap _inspired_ dropdown button where you hover and it gives you more options
            for mobile accessibility tapping it should show/hide the dropdown 
        -->
        
        <div class="pt-4 block relative">
            <div class="">
                <h2>Scenarios</h2>
            </div>
            <div class="group absolute left-auto right-0 z-9 w-auto top-0" v-if="scenarios?.length">
                <button class="bg-blue-500 text-white font-bold py-2 px-4 rounded ">Actions &#9660;</button>
                <div class="absolute left-0 top-10 overflow-auto rounded-md shadow-lg py-1 hidden group-hover:flex flex-col shadow w-40 -ml-20" 
                role="menu" 
                aria-orientation="vertical" 
                aria-labelledby="options-menu">
                    <button class="w-full text-left block px-4 py-2 text-sm text-gray-700 hover:bg-blue-500 hover:text-white" role="menuitem"><span style="color:white;">&#9658;</span> Run All Scenarios</button>
                    <button class="w-full text-left block px-4 py-2 text-sm text-gray-700 hover:bg-red-500 hover:text-white" role="menuitem">&#x1F6D1; Stop All Scenarios</button>
                </div>
            </div>
        </div>
        
        <div v-if="!scenarios?.length" class="pt-20 pb-12">
            No Scenarios Found.
        </div>

        <div v-if="scenarios?.length" class="pt-20 pb-12">
            
            <!-- Scenarios:
            <pre>{{ scenarios }}</pre> -->
            <!-- <pre>#scenarios:{{scenarios?.length}}
#selectedScenarioIndex:{{selectedScenarioIndex}}
            </pre> -->
            <draggable class="space-y-2" :item-key="'blah'" v-model="scenarios" @end="endDrag">
                <template #item="{element, index}">
                    <div :key="index" 
                    class="p-2 border rounded cursor-pointer"
                    :class="[
                    selectedScenarioIndex === index ? 'bg-purple-900 text-white' : 'bg-black-10 text-white'
                    ]"
                        @click="selectScenarioIndex(index)">
                        {{ index + 1 }}) {{ element.title }}
                    </div>
                </template>
            </draggable>
        </div>
    </div>
</script>

<!-- ScenarioDetails -->
<script type="text/x-template" id="scenario-details-template">
    <div class="w-full ml-4 p-4 h-screen overflow-y-auto">
        <!-- <span>Selected Scenario:</span>
        <h1 class="text-l font-bold mb-4 text-white">{{selectedScenarioIndex + 1}}) {{ selectedScenario?.title ?? 'No Scenario Selected' }}</h1> -->
        <div class="overflow-hidden space-x-2 mb-4">
            <button 
                v-if="!selectedScenario.running"
                class="w-auto group text-left inline-block px-4 py-2 text-sm bg-blue-500 hover:bg-green-600 text-white rounded transition-all duration-300" 
                role="menuitem"
            >
                <span style="color:white;" class="inline-block float-left">&#9658;</span> 
                <span class="overflow-hidden transition-all duration-200 ease-in-out w-0 group-hover:w-28 group-hover:px-2 inline-block float-left">
                    <span class="w-28 block">Run Scenario</span>
                </span>
            </button>
            <button 
            v-if="selectedScenario.running"
            class="w-auto text-left inline-block px-4 py-2 text-sm bg-red-500 hover:bg-red-700 text-white rounded" role="menuitem">&#x1F6D1; Stop Scenario</button>
        </div>
        <div v-if="!selectedScenario">
            <p>Select a scenario to view details</p>
        </div>
        <div v-if="selectedScenario">
            <div class="mb-4" v-for="(item, index) in selectedScenario.given" :key="'given-' + index">
                <label class="block text-cyan-700">Given</label>
                <vue-typeahead
                    :v-model="item"
                    :backingData="searchableGivenNames"
                    :minChars="1"
                    placeholder="given..."
                    class="given-input w-full p-2 border rounded caret-down relative"
                ></vue-typeahead>
            </div>
            <div class="mb-4" v-for="(item, index) in selectedScenario.when" :key="'when-' + index">
                <label class="block text-blue-700">When</label>
                <vue-typeahead
                    :v-model="item"
                    :backingData="searchableWhenNames"
                    :minChars="1"
                    placeholder="when..."
                    class="when-input w-full p-2 border rounded caret-down relative"
                ></vue-typeahead>
            </div>
            <div class="mb-4" v-for="(item, index) in selectedScenario.then" :key="'then-' + index">
                <label class="block text-orange-700">Then</label>
                <vue-typeahead
                    :v-model="item"
                    :backingData="searchableThenNames"
                    :minChars="1"
                    placeholder="then..."
                    class="then-input w-full p-2 border rounded caret-down relative"
                ></vue-typeahead>
            </div>
            <button id="deleteBtn" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded" @click="showDeleteModal">Delete</button>
            <div class="pt-4">
                <br/><hr/><br/>
                <h4>Scenario Run History:</h4>
                <div>TODO!</div>
            </div>
        </div>
    </div>
</script>

<script type="text/x-template" id="delete-modal-template">
    <div class="delete-modal modal absolute inset-0 flex items-center justify-center rounded-lg z-100">
        <div class="modal-content text-center relative rounded-2xl w-auto pt-4 px-12">
            <span class="close absolute right-2 -top-1" @click="hideDeleteModal">&times;</span>
            <p>Are you sure you want to delete this scenario?</p>
            <div class="text-center mt-4">
                <button class="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded inline-block mx-2" @click="hideDeleteModal">No</button>
                <button class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded inline-block" @click="deleteScenario">Yes</button>
            </div>
        </div>
    </div>
</script>

<script type="text/x-template" id="confirm-modal-template">
    <div class="delete-modal modal absolute inset-0 flex items-center justify-center rounded-lg z-100">
        <div class="modal-content text-center relative rounded-2xl w-auto pt-4 px-12">
            <span class="close absolute right-2 -top-1" @click="hideDeleteModal">&times;</span>
            <p>Are you sure?</p>
            <div class="text-center mt-4">
                <button class="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded inline-block mx-2" @click="hideDeleteModal">No</button>
                <button class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded inline-block" @click="deleteScenario">Yes</button>
            </div>
        </div>
    </div>
</script>

<!-- #vue-typeahead-template -->
<script type="text/x-template" id="vue-typeahead-template">
    <div :class="className" class="vue-typeahead">
        <input type="text" class="w-full p-2 border rounded caret-down relative" 
            :class="{'bg-blue-200': searching}"
            :placeholder="placeholder"
            name="garbage"
            autocomplete="off"
            :value="localInput"
            @focus="onFocusIn"
            @blur="onFocusOut"
            @input="onTypeaheadValueInput" />
        <div class="relative">
            <ul class="overflow-y-auto absolute left-0 z-10 w-full typeahead-dropdown border rounded shadow-lg" v-if="showDropdown && localFilteredSet.length > 0">
                <li class="clearfix"><div class="float-left">Features:</div><div class="float-right">Status:</div></li>
                <li class="p-2 hover:bg-purple-100 cursor-pointer clearfix"
                    :class="{ 'bg-blue-200': index === highlightedOptionIndex }"
                    v-for="(item, index) in localFilteredSet" :key="index" @click="clickItem(index)">
                    <div class="float-left">{{index+1}}) {{ item }}</div>
                    <div class="float-right">âœ…</div>
                </li>
                <li class="p-2 hover:bg-blue-100 cursor-pointer" @click="clickItem.bind('__NEW_THING__')">
                    New {{newThingName}}{{ vModel.length ? ' '+vModel : '' }}...
                </li>
            </ul>
        </div>
    </div>
</script>


<script>
    window.VueNextTypeahead = {
        name: 'vue-typeahead',
        template: "#vue-typeahead-template",
        props: {
            newThingName: {
                type: String,
                default: 'Thing'
            },
            showDropdownOnFocus: {
                type: Boolean,
                default: true
            },
            apiUrl: {
                type: String,
                required: false
            },
            backingData: {
                type: Array,
                required: false
            },
            input: {
                type: String,
                default: ''
            },
            title: {
                type: String,
                default: null
            },
            className: {
                type: String,
                default: ''
            },
            items: {
                type: Array,
                default: () => []
            },
            keyItem: {
                type: String,
                default: null
            },
            showTitle: {
                type: Boolean,
                default: true
            },
            placeholder: {
                type: String,
                default: 'QuÃ© necesitas...'
            },
            noResultsText: {
                type: String,
                default: 'No existen resultados para esa bÃºsqueda...'
            },
            minChars: {
                type: Number,
                default: 2,
                validator: (value) => {
                    return value > 0
                }
            },
            delay: {
                type: Number,
                default: 500
            },
            loadingParentComponent: {
                type: Boolean,
                default: false
            },
            vModel: {
                type: String,
                required: true
            }
        },
        data() {
            return {
                searching: false,
                focusing: false,
                showDropdown: false,
                timeout: '',
                highlightedOptionIndex: 0,
                localInput: '',
                localFilteredSet: []
            }
        },
        mounted() {
            this.localInput = this?.vModel ?? this?.input ?? ''
            document.addEventListener('click', (e) => {
                //console.warn('should we close the dropdown?', e.target, this.$el)
                // if (!this.$el.contains(e.target)) {
                //     this.reset()
                // }
            })
        },
        methods: {
            onTypeaheadValueInput(event) {
                this.localInput = event.target.value
                //this.$emit('update:vModel', event.target.value)
                if (event.target.value.length >= this.minChars) {
                    this.search()
                }
                if (event.target && event.target.value.length === 0) {
                    this.reset()
                }
            },
            search() {
                this.searching = true
                // emit
                this.$emit('searching', true)
                clearTimeout(this.timeout)
                this.timeout = setTimeout(async () => {
                    try {
                        let response;
                        if (this.backingData && this.backingData.length > 0) {
                            //console.warn('backingData', this.backingData)
                            // Filter the backingData based on the inputLocalCache value
                            response = this.backingData.filter(item => {
                                // item might be an object or a string
                                if(typeof item === 'object'){
                                    if(item?.name?.length){
                                        return item.name.toLowerCase().includes(this.localInput.toLowerCase())
                                    }
                                    throw new Error('backingData item is an object but does not have a "name" property')
                                }
                                return item.toLowerCase().includes(this.localInput.toLowerCase())
                            });
                            //console.warn('filtered:', response)
                        } else {
                            // Fetch data from the apiUrl
                            response = await fetch(this.apiUrl)
                        }
                        this.localFilteredSet = response
                        this.$emit('filteredOptionsUpdated', response)
                    } catch (error) {
                        console.error('Error occurred during search:', error);
                        this.$emit('error', error)
                    } finally {
                        clearTimeout(this.timeout)
                        this.showDropdown = true
                        this.searching = false
                        this.$emit('searching', false)
                    }
                }, 0)//this.delay)
            },
            // changeInput(event) {
            //     if (event?.target?.value?.length >= this.minChars) {
            //         this.search()
            //     }
            //     this.$emit('update:input', event.target.value)
            //     if (event.target && event.target.value.length === 0) {
            //         this.reset()
            //     }
            // },
            onFocusIn() {
                this.focused = true
                this.$emit('focus')
                if(this.showDropdownOnFocus){
                    this.search()
                }
            },
            onFocusOut() {
                this.$emit('blur')
                this.focused = false
                //this.reset()
            },
            clickItem(item) {
                console.warn('clickItem',arguments);
                this.$emit('hit', item)
                this.reset()
            },
            // highlight(text, term) {
            //     if (text && term) {
            //         var index = text.toLowerCase().indexOf(term.toLowerCase())
            //         if (index >= 0) {
            //             text = `${text.substring(0, index)}<span style="font-weight: 600;">${text.substring(index, index + term.length)}</span>${text.substring(index + term.length)}`
            //         }
            //     }
            //     return text
            // },
            reset() {
                console.warn('VueTypeahead: reset');
                this.showDropdown = false
                this.searching = false
                this.$emit('reset')
                //this.$emit('update:input', '')
            }
        }
    }


</script>

<style>
.vue-next-typeahead {
    width: 460px;
    display: block;
    position: relative;
}

.vue-next-typeahead__title {
    font-size: 16px;
    font-style: normal;
    font-weight: 600;
    line-height: 22px;
    letter-spacing: 0px;
    text-align: left;
    display: block;
    margin-bottom: 8px;
}

.vue-next-typeahead__wrapper-input {
    height: 48px;
    background: #FFFFFF;
    border: 1px solid #D2D2D2;
    box-sizing: border-box;
    border-radius: 4px;
    padding: 0 15px 0 16px;
    position: relative;
}

.vue-next-typeahead__wrapper-input > input {
    height: 48px;
    border-radius: 0;
    border: 0;
    outline: none;
    font-size: 16px;
    font-style: normal;
    font-weight: 400;
    line-height: 22px;
    letter-spacing: 0px;
    text-align: left;
    margin-right: 8px;
    width: calc(100% - 32px);
    padding: 0;
    max-height: 100%;
    color: #404040;
    background: transparent;
}

.vue-next-typeahead__wrapper-input > input::placeholder {
    color: #D2D2D2;
}

.vue-next-typeahead__wrapper-input .ico-search,
.vue-next-typeahead__wrapper-input .ico-loader {
    vertical-align: middle;
    background-size: cover;
    display: inline-block;
    width: 24px;
    height: 24px;
}
.vue-next-typeahead__wrapper-input .ico-search {
    background-image: url('../assets/search.svg');
}
.vue-next-typeahead__wrapper-input .ico-loader {
    background-image: url('../assets/loader-orange.svg');
    -webkit-animation:spin 4s linear infinite;
    -moz-animation:spin 4s linear infinite;
    animation:spin 4s linear infinite;
}
@-moz-keyframes spin { 100% { -moz-transform: rotate(360deg); } }
@-webkit-keyframes spin { 100% { -webkit-transform: rotate(360deg); } }
@keyframes spin { 100% { -webkit-transform: rotate(360deg); transform:rotate(360deg); } }

.vue-next-typeahead__wrapper-input:hover:not(.vue-next-typeahead__wrapper-input--focusing) {
    background: #FAFAFA;
    border: 1px solid #9B9B9B;
}

.vue-next-typeahead__wrapper-input:hover:not(.vue-next-typeahead__wrapper-input--focusing) > input::placeholder {
    color: #9B9B9B;
}

.vue-next-typeahead__wrapper-input--focusing {
    box-shadow: 0px 0px 8px 0px #FF7300 20%;
    border: 1px solid #FF7300;
    box-sizing: border-box;
    box-shadow: 0px 0px 8px rgba(255, 115, 0, 0.2);
}
.vue-next-typeahead__wrapper-input--focusing .ico-search {
    background-image: url('../assets/search-orange.svg');
}

.vue-next-typeahead__dropdown {
    border: 1px solid #D2D2D2;
    list-style: none;
    width: calc(100% - 2px);
    padding: 16px 0 0;
    margin: -14px 0 0 0;
    max-height: 336px;
    overflow-y: auto;
}

.vue-next-typeahead__dropdown > li {
    min-height: 42px;
    padding: 0 16px;
    font-size: 16px;
    font-style: normal;
    letter-spacing: 0px;
    text-align: left;
    cursor: pointer;
}

.vue-next-typeahead__dropdown > li:hover {
    background: #FAFAFA;
}

.vue-next-typeahead__dropdown > li > span {
    line-height: 42px;
}

.vue-next-typeahead__dropdown > li.li-no-results {
    line-height: 42px;
    cursor: auto;
}

.vue-next-typeahead__dropdown::-webkit-scrollbar {
    -webkit-appearance: none;
    width: 5px;
    height: 6px;
}

.vue-next-typeahead__dropdown::-webkit-scrollbar-thumb {
    border-radius: 12px;
    border: 4px solid rgba(255, 255, 255, 0);
    background-color: #bdbdbd;
}

.vue-next-typeahead__dropdown::-webkit-scrollbar-corner {
    background-color: transparent;
}

@media screen and (max-width: 768px) {
.vue-next-typeahead {
    width: 100%;
}
}
</style>

<script>
    function start(){
        const { ref, toRefs, computed, reactive, readonly } = Vue;
        const state = reactive({
            events: {},

            // TODO: move selectedScenarioIndex here

            // bool flag for delete modal visibility
            // todo: make into a generic "are you sure" confirmation modal
            showingModal: 0, // used for underlay to prevent clicks
            showDeleteModal: 0,

            selectedFeatureIndex: 0,
            newScenarioNameInput: '',
            featureSearchInput: '',
        });
        window.gwt_state = state;

        const EventBus = {
            emit(event, data) {
                if (!state.events[event]) {
                state.events[event] = [];
                }
                state.events[event].push(data);
            },
            on(event, callback) {
                if (!state.events[event]) {
                state.events[event] = [];
                }
                state.events[event].push(callback);
            },
            off(event, callback) {
                if (state.events[event]) {
                const index = state.events[event].indexOf(callback);
                if (index > -1) {
                    state.events[event].splice(index, 1);
                }
                }
            }
        };
        // freeze the EventBus object so it can't be modified
        const MainEventBus = readonly(EventBus);
        window.gwt_eventbus = MainEventBus;
        const app = Vue.createApp({
            setup() {
                const features = ref([{
                    name: 'GWT MVP -- Features',
                    description: 'This is the minimum viable product for the Gherkin Web Test Manager',
                    scenarios: [{
                        title: 'user adds a feature',
                        given: ['user is on the main page'],
                        when: ['user submits a new feature name'],
                        then: [
                            'user sees the new feature in the feature list',
                            'user sees the new feature is selected',
                            'user sees the new feature\'s "new scenario..." input is focused'
                        ]
                    },{
                        title: 'user searches for another feature',
                        given: ['user is on the main page'],
                        when: ['user enters a search term into the feature selector'],
                        then: ['user sees the search results']
                    },{
                        title: 'user selects another feature',
                        given: ['user is on the main page'],
                        when: ['user clicks on a feature in the feature selector'],
                        then: ['user sees the selected feature\'s scenarios']
                    },{
                        title: 'ðŸ”µ user renames a feature',
                        given: ['user is on the main page', 'user has selected a feature'],
                        when: ['user renames the selected feature'],
                        then: ['user sees the renamed feature in the feature list']
                    },{
                        title: 'ðŸ”µ user archives a feature',
                        given: ['user is on the main page', 'user has selected a feature'],
                        when: ['user archives the selected feature'],
                        then: ['user sees the archived feature in the archived features list']
                    },{
                        title: 'ðŸ”µ user deletes a feature',
                        given: ['user is on the main page', 'user has selected a feature'],
                        when: ['user deletes the selected feature'],
                        then: ['user does not see the deleted feature in the feature list']
                    }]
                },{
                    name: 'GWT MVP -- Scenarios',
                    scenarios: [{
                        title: 'user adds a scenario',
                        given: ['user is on the main page'],
                        when: ['user submits a new scenario name'],
                        then: [
                            'user sees the new scenario in the scenario list',
                            'user sees the new scenario is selected',
                            'user sees the new scenario\'s "given" input is focused'
                        ]
                    },{
                        title: 'user deletes a scenario',
                        given: ['user is on the main page'],
                        when: ['user clicks delete scenario'],
                        then: ['user is prompted to confirm deletion']
                    },{
                        title: 'user confirms deletion of a scenario',
                        given: ['user is on the main page','user clicked delete scenario'],
                        when: ['user clicks confirm delete scenario'],
                        then: ['user sees the scenario is deleted']
                    }]
                },{
                    name: 'GWT MVP -- Running Scenarios',
                    scenarios: [
                        {
                            title: 'user runs a scenario',
                            given: ['user selected a scenario'],
                            when: ['user clicks run scenario'],
                            then: [
                                'user sees the scenario enters the running state',
                                'user sees the scenario\'s run history is updated',
                                'user eventuall sees final result of the scenario\'s run'
                            ]
                        }
                    ]
                },{
                    name: 'GWT MVP -- Type Ahead Field',
                    scenarios: [
                        {
                            title: 'user searches for a value',
                            given: ['user focused in a type ahead field'],
                            when: ['user enters a search term into the type ahead field'],
                            then: ['user sees the search results']
                        }
                    ]
                },{
                    name: 'ðŸ‘¤ User Registration',
                    description: 'All scenarios around registering and verifying a new web account',
                    scenarios: [{
                        title: 'ðŸ‘¤ user registers web account',
                        given: ['user is on the registration page'],
                        when: ['user enters their details'],
                        then: ['user is registered']
                    },{
                        title: 'âš ï¸ user sees validation errors when submitting bad data to registration form',
                        given: ['user is on the registration page'],
                        when: ['user enters invalid details'],
                        then: ['user sees validation errors']
                    },{
                        title: 'ðŸ” user gets duplicate email notice when registering with an email that already exists',
                        given: ['user account exists for email'],
                        when: ['user enters an email that already exists'],
                        then: ['user sees duplicate email notice in email inbox']
                    },{
                        title: 'ðŸ“§ user gets verification email after registering',
                        given: ['user submitted web account registration form'],
                        when: ['user checks email'],
                        then: ['user sees verification email']
                    },{
                        title: 'âœ… user clicks verification link in email',
                        given: ['user received verification email'],
                        when: ['user clicks verification link'],
                        then: ['user is verified']
                    }]
                },{
                    name: 'ðŸ—ï¸ User Authentication: Happy Path',
                    scenarios:[{
                        title: 'user logs in via login page',
                        given: ['user is on the login page'],
                        when: ['user enters their email and password'],
                        then: ['user is logged in']
                    },{
                        title: 'user logs in via main menu',
                        given: ['user is on the home page'],
                        when: ['user submits their email and password into the main menu'],
                        then: ['user is logged in']
                    },{
                        title: 'user logs in via modal',
                        given: ['user sees the login modal'],
                        when: ['user submits their email and password into the modal'],
                        then: ['user is logged in']
                    }]
                },{
                    name: 'âŒ User Authentication: Edge Cases',
                    scenarios:[{
                        title: 'user submits invalid email/password via login page',
                        given: ['user is on the login page'],
                        when: ['user enters invalid email and password'],
                        then: ['user sees validation errors on the login form']
                    },{
                        title: 'user submits invalid email/password via main menu',
                        given: ['user is on the home page'],
                        when: ['user submits invalid email and password into the main menu'],
                        then: ['user is redirected to login page with validation errors present']
                    },{
                        title: 'user submits invalid email/password via modal',
                        given: ['user sees the login modal'],
                        when: ['user submits invalid email and password into the modal'],
                        then: ['user sees validation errors in the modal']
                    }]
                },{
                    name: 'ðŸ”‘ User Password Actions',
                    description: 'All scenarios around changing and resetting a user\'s password',
                    scenarios: [{
                        title: 'user forgets password, requests reset',
                        given: ['user is on the login page'],
                        when: ['user clicks forgot password link and submits email address'],
                        then: ['user receives password reset email']
                    },{
                        title: 'user clicks password reset link in email',
                        given: ['user received password reset email'],
                        when: ['user clicks password reset link'],
                        then: ['user is taken to password reset page']
                    },{
                        title: 'user resets password',
                        given: ['user is on the password reset page'],
                        when: ['user enters new password and submits form'],
                        then: ['user is logged in']
                    },{
                        title: 'user changes password',
                        given: ['user is logged in'],
                        when: ['user clicks change password link and submits form'],
                        then: ['user is logged in']
                    },{
                        title: 'user visits reset password page with invalid token',
                        given: ['user is on the password reset page'],
                        when: ['user enters new password and submits form'],
                        then: ['user sees invalid token error']
                    }]
                },{
                    name: 'ðŸ” KYC',
                    scenarios:[],
                },{
                    name: 'ðŸ“± SMS',
                    scenarios:[],
                },{
                    name: 'ðŸš« Banned Users',
                    scenarios:[],
                },{
                    name: 'ðŸ‘ï¸ Watched Lots',
                    scenarios:[],
                },{
                    name: 'ðŸ“ Sale Registration',
                    scenarios:[],
                },{
                    name: 'ðŸ’° Pre-sale Bidding',
                    scenarios:[],
                },{
                    name: 'ðŸ“† Day Of Sale',
                    scenarios:[],
                }])
                const selectedFeatureIndex = ref(0);
                const selectedScenarioIndex = ref(0);

                const addScenario = () => {
                    console.warn("Global Action: addScenario", arguments); 
                    if(selectedFeature == null){
                        console.warn("addScenario: selectedFeature is null");
                        return;
                    }
                    if (!state.newScenarioNameInput.length) {
                        console.error('cannot add a scenario with no name');
                        return;
                    }
                    if(!features.value[selectedFeatureIndex.value]){
                        console.warn("addScenario: selectedFeatureIndex is null");
                        return;
                    }
                    features.value[selectedFeatureIndex.value].scenarios.push({ 
                        title: state.newScenarioNameInput,
                        given: [''], 
                        when: [''], 
                        then: [''] 
                    });
                    // reset the input to blank
                    window.gwt_state.newScenarioNameInput = '';
                    // set it as the selected scenario
                    selectedScenarioIndex.value = features.value[selectedFeatureIndex.value].scenarios.length - 1;
                    setTimeout(()=>{
                        // focus the first input in the scenario details
                        document.querySelector('.given-input input').focus();
                    },100)
                };

                const selectFeatureIndex = (featureIndex) => {
                    if(!features.value[featureIndex]){
                        console.warn("selectFeatureIndex: featureIndex is null");
                        return;
                    }
                    selectedFeatureIndex.value = featureIndex;
                };

                const selectScenarioIndex = (scenarioIndex) => {
                    //console.warn('selectScenarioIndex: scenarioIndex:', scenarioIndex);
                    selectedScenarioIndex.value = scenarioIndex;
                };

                // Getters (computed) for SelectedFeature and SelectedScenario
                const selectedFeature = computed(() => {
                    const feature = features.value[selectedFeatureIndex.value];
                    //console.warn('selectedFeature:', feature);
                    return feature;
                });

                const selectedScenario = computed(() => {
                    const scenario = selectedFeature.value.scenarios[selectedScenarioIndex.value];
                    //console.warn('selectedScenario:', scenario);
                    return scenario;
                });

                // MainEventBus.on('...', (value) => {
                //     console.warn('...', value);
                //     state.... = value;
                // });

                const searchableFeatureNames = computed(() => {
                    return features.value.map(feature => feature.name);
                });

                const searchableScenarioNames = computed(() => {
                    const values = [];
                    // loop through ALL features > scenarios and collect into a unique set
                    features.value.forEach(feature => {
                        feature.scenarios.forEach(scenario => {
                            if(!values.some(value => value.name === scenario.title)){
                                values.push({
                                    name: scenario.title,
                                });
                            }
                        });
                    });
                    return values;
                });

                const searchableGivenNames = computed(() => {
                    const values = [];
                    // loop through ALL features > scenarios > given and collect into a unique set
                    features.value.forEach(feature => {
                        feature.scenarios.forEach(scenario => {
                            scenario.given.forEach(given => {
                                // if(!values.some(value => value.name === given)){
                                //     values.push({
                                //         name: given,
                                //     });
                                // }
                                if(!values.includes(given)){
                                    values.push(given);
                                }
                            });
                        });
                    });
                    return values;
                });
                const searchableWhenNames = computed(() => {
                    const values = [];
                    // loop through ALL features > scenarios > when and collect into a unique set
                    features.value.forEach(feature => {
                        feature.scenarios.forEach(scenario => {
                            scenario.when.forEach(when => {
                                // if(!values.some(value => value.name === when)){
                                //     values.push({
                                //         name: when,
                                //     });
                                // }
                                if(!values.includes(when)){
                                    values.push(when);
                                }
                            });
                        });
                    });
                    return values;
                });
                const searchableThenNames = computed(() => {
                    const values = [];
                    // loop through ALL features > scenarios > then and collect into a unique set
                    features.value.forEach(feature => {
                        feature.scenarios.forEach(scenario => {
                            scenario.then.forEach(then => {
                                // if(!values.some(value => value.name === then)){
                                //     values.push({
                                //         name: then,
                                //     });
                                // }
                                if(!values.includes(then)){
                                    values.push(then);
                                }
                            });
                        });
                    });
                    return values;
                });

                const deleteScenario = () => {
                    console.warn('deleteScenario', {
                        selectedFeatureIndex: selectedFeatureIndex.value,
                        selectedScenarioIndex: selectedScenarioIndex.value,
                        selectedScenario: selectedScenario,
                    });
                    if(selectedFeatureIndex.value === null){
                        console.error("deleteScenario: selectedFeatureIndex is null");
                        return;
                    }
                    if(selectedScenarioIndex.value === null){
                        console.error("deleteScenario: selectedScenarioIndex is null");
                        return;
                    }
                    const scenarios = selectedFeature.value.scenarios;
                    if(!scenarios || !scenarios[selectedScenarioIndex.value]){
                        console.error("deleteScenario: scenarios[selectedScenarioIndex] is null",{selectedFeature:selectedFeature.value,scenarios});
                        return;
                    }
                    
                    scenarios.splice(selectedScenarioIndex.value, 1);
                    // hide modal
                    gwt_state.showDeleteModal = false;
                    gwt_state.showingModal = false;
                };

                const endDrag = (thing) => {
                    // Handle drag end event
                    console.warn('handle drag end',{thing:unwrap(thing)});

                    // update scenario's position in the array
                    // thing.oldIndex -> thing.newIndex
                    console.warn(`from ${thing.oldIndex} to ${thing.newIndex}`);

                    if(!features.value[selectedFeatureIndex.value]){
                        console.warn("endDrag: selectedFeatureIndex is null");
                        return;
                    }
                    if(!features.value[selectedFeatureIndex.value].scenarios[thing.oldIndex]){
                        console.warn("endDrag: scenarios[selectedScenarioIndex] is null");
                        return;
                    }

                    let tempThing = features.value[selectedFeatureIndex.value].scenarios[thing.oldIndex];
                    features.value[selectedFeatureIndex.value].scenarios.splice(thing.oldIndex, 1);
                    features.value[selectedFeatureIndex.value].scenarios.splice(thing.newIndex, 0, tempThing);

                    // update selectedScenarioIndex
                    selectedScenarioIndex.value = thing.newIndex;
                };

                const showDeleteModal = computed(() => {
                    return state.showDeleteModal;
                });
                const showingModal = computed(() => {
                    return state.showingModal;
                });
                const scenarios = computed(()=> {
                    return selectedFeature?.value?.scenarios ?? [];
                })

                const app_stuff = {
                    features,
                    scenarios,
                    searchableFeatureNames,
                    searchableScenarioNames,
                    searchableGivenNames,
                    searchableWhenNames,
                    searchableThenNames,
                    selectedFeatureIndex,
                    selectedFeature,
                    selectedScenarioIndex,
                    selectedScenario,

                    showingModal,
                    showDeleteModal,

                    addScenario,
                    selectFeatureIndex,
                    selectScenarioIndex,
                    deleteScenario,
                    endDrag,
                };
                Object.defineProperty(window, 'gwt_app', {
                    get: () => app_stuff,
                    set: (value) => {
                        console.error('cannot set gwt_app, it is readonly')
                    }
                });
                return app_stuff;
            }
        });
        app.component('draggable', window.vuedraggable)
        //console.warn('registering VueNextTypeahead', window.VueNextTypeahead);
        app.component('vue-typeahead', window.VueNextTypeahead)
        // FeatureSelector
        app.component('feature-selector', {
            template: '#feature-selector-template',
            data(){
                return {
                    searching: false,
                    focused: false
                }
            },
            props: [
                'selectedFeatureIndex',
                'selectedFeature', 
                'features',
                'searchableFeatureNames'
            ],
            methods:{
                // via filtered-options-updated aka filteredOptionsUpdated
                onFeatureSelectorResultsUpdated: function(results){
                    //console.warn('onFeatureSelectorResultsUpdated', results);
                },
                onFeatureSelectorSelect: function(index){
                    console.warn('onFeatureSelectorSelect', index);
                    //this.$emit('select-feature-index', index);
                },
                onFeatureSelectorHit: function(index){
                    console.warn('onFeatureSelectorHit', index);
                    // this.$emit('select-feature-index', index);
                    window.gwt_app.selectFeatureIndex(index);
                },
                onSearchingStateChanged: function(isSearching){
                    //console.warn('onSearchingStateChanged', isSearching);
                    this.searching = isSearching;
                },
                onFeatureSelectorReset: function(){
                    window.gwt_state.newScenarioNameInput = '';
                },
                onFocusIn(){
                    this.focused = true;
                },
                onFocusOut(){
                    this.focused = false;
                }
            },
            computed:{
                featureSelectorInput: {
                    get(){
                        // if we're focused, it's a text input, not a header
                        if(this.focused){
                            return window.gwt_state.featureSearchInput;
                        }
                        // show the currently selected feature (if any)
                        return 'Feature ' + (this.selectedFeatureIndex + 1) + ') ' + this.selectedFeature?.name ?? '';
                        
                    },
                    set(value){
                        window.gwt_state.featureSearchInput = value;
                    }
                }
            },
            mounted(){
                console.warn('FeatureSelector',{
                    $props: this.$props,
                    props: JSON.parse(JSON.stringify(this.$props)),
                    _this: this
                })
                // focus the input
                setTimeout(()=>{
                    document.querySelector('.feature-selector input').focus();
                },100)
            }
        });
        // ScenarioList
        app.component('scenario-list', {
            template: '#scenario-list-template',
            props: [
                'scenarios', 
                'addScenario',
                'selectedScenarioIndex', 
                'selectScenarioIndex', 
                'endDrag',
            ],
            computed:{
                newScenarioNameInput: {
                    get(){
                        return window.gwt_state.newScenarioNameInput;
                    },
                    set(value){
                        window.gwt_state.newScenarioNameInput = value;
                    }
                }
            },
            data(){
                return {
                    showDropdown: false
                }
            },
            mounted(){
                console.warn('ScenarioList',{
                    $props: this.$props,
                    props: JSON.parse(JSON.stringify(this.$props)),
                    _this: this
                })
            }
        });
        // ScenarioDetails
        app.component('scenario-details', {
            template: '#scenario-details-template',
            props: [
                'selectedScenarioIndex',
                'selectedScenario', 
                'searchableGivenNames', 
                'searchableWhenNames',
                'searchableThenNames'
            ],
            methods:{
                showDeleteModal(){
                    window.gwt_state.showDeleteModal = true;
                    window.gwt_state.showingModal = true;
                }
            },
        });
        app.component('delete-modal', {
            template: '#delete-modal-template',
            props: ['deleteScenario'],
            methods:{
                hideDeleteModal(){
                    window.gwt_state.showDeleteModal = false;
                    window.gwt_state.showingModal = false;
                }
            }
        });
        
        app.mount('#app');
    }
    document.addEventListener('DOMContentLoaded', start);
</script>
</body>