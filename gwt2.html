<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gherkin Test Manager</title>
    
    <script src="https://unpkg.com/vue@3.3.13"></script>
    <script src="https://unpkg.com/sortablejs@1.10.2"></script>
    <script src="https://unpkg.com/vuedraggable@4.0.1"></script>
    <!-- <script src="https://unpkg.com/vue-next-typeahead@0.0.2"></script> -->

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Open Sans', sans-serif;
        }
        .fixed-top {
            position: fixed;
            top: 0;
            left: 0;
            width: 33.3333%;
            background-color: #fff; /* Light theme */
            border-right: 1px solid #e5e7eb; /* Light theme border */
        }

        .left-panel {
            margin-top: /* Height of the .fixed-top element */;
            width: 33.3333%;
            height: calc(100% - /* Height of the .fixed-top element */);
            overflow-y: auto;
        }

        .main-content {
            width: 66.6667%;
            /* Other styles */
        }
        .caret-down::after {
            content: '▼';
            padding-left: 8px;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 10;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgb(0,0,0);
            background-color: rgba(0,0,0,0.4);
            padding-top: 60px;
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-gray-100">

<div id="app" class="flex p-4">
    <feature-selector></feature-selector>
    <scenario-list 
        :addScenario="addScenario"
        :scenarios="scenarios"
        :newScenarioNameInput="newScenarioNameInput"
        :selectScenarioIndex="selectScenarioIndex"
        :endDrag="endDrag"
    ></scenario-list>
    <scenario-details v-if="selectedScenario"
        :selectedScenario="selectedScenario"
        :searchableGivenNames="searchableGivenNames"
        :searchableWhenNames="searchableWhenNames"
        :searchableThenNames="searchableThenNames"
    ></scenario-details>
    <delete-modal v-if="showDeleteModal"></delete-modal>
</div>

<!-- Feature Selector is a type-head text field that doubles as a H1 header for the selected Feature as well as an input that allows you to fuzzy-search to switch the selected feature, and there's always a default option to "Create New Feature Named... %whatever the user was typing%" -->
<script type="text/x-template" id="feature-selector-template">
    <div class="w-full p-4">
        <h1 class="text-2xl font-bold mb-4">{{ featureSelectorInput ?? '' }}</h1>
        <vue-typeahead
            @searching="onSearchingStateChanged"
            v-model="featureSelectorInput"
            :backingData="searchableFeatureNames"
            :items="features"
            :minChars="1"
            placeholder="Search or create a new feature..."
            :class="{'animate-pulse bg-blue-200': searching}"
            @input="updateFeature"
        ></vue-typeahead>
    </div>
</script>


<!-- ScenarioList -->
<script type="text/x-template" id="scenario-list-template">
    <div class="w-1/3 h-screen overflow-y-auto">
        <div class="fixed-top p-4">
            <input type="text" placeholder="New Scenario Name..." class="w-full p-2 mb-4 border rounded caret-down" v-model="newScenarioNameInput" />
             <!-- @keyup.enter="this.addScenario" -->
        </div>
        <!-- <div v-if="scenarios?.length">
            <draggable class="space-y-2" v-model="scenarios" @end="endDrag">
                <div v-for="(scenario, index) in scenarios" 
                    :item-key="index"
                    :key="index" class="p-2 border rounded bg-gray-50 cursor-pointer" 
                    @click="selectScenarioIndex(index)">
                    {{ scenario.title }}
                </div>
            </draggable>
        </div> -->
    </div>
</script>

<!-- ScenarioDetails -->
<script type="text/x-template" id="scenario-details-template">
    <div class="w-2/3 ml-4 p-4 h-screen overflow-y-auto">
        <h1 class="text-2xl font-bold mb-4">{{ selectedScenario?.title ?? 'No Scenario Selected' }}</h1>
        <div class="mb-4" v-for="(item, index) in selectedScenario.given" :key="'given-' + index">
            <label class="block text-gray-700">Given</label>
            <vue-typeahead
                v-model="selectedScenario.given[index]"
                :backingData="searchableGivenNames"
                :items="givenItems"
                :minChars="1"
                placeholder="Search or create a new given..."
                class="w-full p-2 border rounded caret-down"
            ></vue-typeahead>
        </div>
        <div class="mb-4" v-for="(item, index) in selectedScenario.when" :key="'when-' + index">
            <label class="block text-gray-700">When</label>
            <vue-typeahead
                v-model="selectedScenario.when[index]"
                :backingData="searchableWhenNames"
                :items="whenItems"
                :minChars="1"
                placeholder="Search or create a new when..."
                class="w-full p-2 border rounded caret-down"
            ></vue-typeahead>
        </div>
        <div class="mb-4" v-for="(item, index) in selectedScenario.then" :key="'then-' + index">
            <label class="block text-gray-700">Then</label>
            <vue-typeahead
                v-model="selectedScenario.then[index]"
                :backingData="searchableThenNames"
                :items="thenItems"
                :minChars="1"
                placeholder="Search or create a new then..."
                class="w-full p-2 border rounded caret-down"
            ></vue-typeahead>
        </div>
        <button id="deleteBtn" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded" @click="showDeleteModal = true">Delete</button>
    </div>
</script>

<script type="text/x-template" id="delete-modal-template">
    <div id="myModal" class="modal">
        <div class="modal-content">
            <span class="close" @click="showDeleteModal = false">&times;</span>
            <p>Are you sure you want to delete this scenario?</p>
            <button class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded" @click="deleteScenario">Yes</button>
            <button class="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded" @click="showDeleteModal = false">No</button>
        </div>
    </div>
</script>

<!-- #vue-typeahead-template -->
<script type="text/x-template" id="vue-typeahead-template">
    <div :class="className">
        <input type="text" class="w-full p-2 border rounded caret-down" v-model="input" @input="$emit('input', $event.target.value)" />
        <div class="relative">
            <ul class="absolute left-0 z-10 w-full bg-white border rounded shadow-lg" v-if="items.length > 0">
                <li class="p-2 hover:bg-blue-100 cursor-pointer" v-for="(item, index) in items" :key="index" @click="$emit('select', item)">
                    {{ item }}
                </li>
            </ul>
        </div>
    </div>
</script>


<script>
    window.VueNextTypeahead = {
        name: 'vue-typeahead',
        template: "#vue-typeahead-template",
        props: {
            apiUrl: {
                type: String,
                required: false
            },
            backingData: {
                type: Array,
                required: false
            },
            input: {
                type: String,
                default: ''
            },
            title: {
                type: String,
                default: null
            },
            className: {
                type: String,
                default: ''
            },
            items: {
                type: Array,
                default: () => []
            },
            keyItem: {
                type: String,
                default: null
            },
            showTitle: {
                type: Boolean,
                default: true
            },
            placeholder: {
                type: String,
                default: 'Qué necesitas...'
            },
            noResultsText: {
                type: String,
                default: 'No existen resultados para esa búsqueda...'
            },
            minChars: {
                type: Number,
                default: 2,
                validator: (value) => {
                    return value > 0
                }
            },
            delay: {
                type: Number,
                default: 500
            },
            loadingParentComponent: {
                type: Boolean,
                default: false
            }
        },
        data() {
            return {
                searching: false,
                focusing: false,
                showDropdown: true,
                timeout: '',
                dataInput: ''
            }
        },
        watch: {
            'input': {
                handler(newVal) {
                    this.dataInput = newVal
                },
                immediate: true
            }
        },
        mounted() {
            document.addEventListener('click', (e) => {
                if (!this.$el.contains(e.target)) {
                    this.reset()
                }
            })
        },
        methods: {
            search() {
                this.searching = true
                // emit
                this.$emit('searching', true)
                clearTimeout(this.timeout)
                this.timeout = setTimeout(async () => {
                    try {
                        let response;
                        if (this.backingData && this.backingData.length > 0) {
                            // Filter the backingData based on the dataInput value
                            response = this.backingData.filter(item => item.toLowerCase().includes(this.dataInput.toLowerCase()));
                        } else {
                            // Fetch data from the apiUrl
                            response = await fetch(this.apiUrl)
                        }
                        this.$emit('response', response)
                    } catch (error) {
                        console.error('Error occurred during search:', error);
                        this.$emit('error', error)
                    } finally {
                        clearTimeout(this.timeout)
                        this.showDropdown = true
                        this.searching = false
                        this.$emit('searching', false)
                    }
                }, this.delay)
            },
            changeInput(event) {
                if (event.target && event.target.value && event.target.value.length >= this.minChars) {
                    this.search()
                }
                this.$emit('update:input', event.target.value)
                if (event.target && event.target.value.length === 0) {
                    this.reset()
                }
            },
            onFocusin() {
                this.focusing = true
            },
            onFocusout() {
                this.focusing = false
                this.searching = false
            },
            clickItem(item) {
                this.$emit('hit', item)
                this.reset()
            },
            highlight(text, term) {
                if (text && term) {
                    var index = text.toLowerCase().indexOf(term.toLowerCase())
                    if (index >= 0) {
                        text = `${text.substring(0, index)}<span style="font-weight: 600;">${text.substring(index, index + term.length)}</span>${text.substring(index + term.length)}`
                    }
                }
                return text
            },
            reset() {
                this.showDropdown = false
                this.searching = false
                this.dataInput = ''
                this.$emit('reset')
                this.$emit('update:input', '')
            }
        }
    }


</script>

<style>
.vue-next-typeahead {
    width: 460px;
    display: block;
    position: relative;
}

.vue-next-typeahead__title {
    font-size: 16px;
    font-style: normal;
    font-weight: 600;
    line-height: 22px;
    letter-spacing: 0px;
    text-align: left;
    display: block;
    margin-bottom: 8px;
}

.vue-next-typeahead__wrapper-input {
    height: 48px;
    background: #FFFFFF;
    border: 1px solid #D2D2D2;
    box-sizing: border-box;
    border-radius: 4px;
    padding: 0 15px 0 16px;
    position: relative;
}

.vue-next-typeahead__wrapper-input > input {
    height: 48px;
    border-radius: 0;
    border: 0;
    outline: none;
    font-size: 16px;
    font-style: normal;
    font-weight: 400;
    line-height: 22px;
    letter-spacing: 0px;
    text-align: left;
    margin-right: 8px;
    width: calc(100% - 32px);
    padding: 0;
    max-height: 100%;
    color: #404040;
    background: transparent;
}

.vue-next-typeahead__wrapper-input > input::placeholder {
    color: #D2D2D2;
}

.vue-next-typeahead__wrapper-input .ico-search,
.vue-next-typeahead__wrapper-input .ico-loader {
    vertical-align: middle;
    background-size: cover;
    display: inline-block;
    width: 24px;
    height: 24px;
}
.vue-next-typeahead__wrapper-input .ico-search {
    background-image: url('../assets/search.svg');
}
.vue-next-typeahead__wrapper-input .ico-loader {
    background-image: url('../assets/loader-orange.svg');
    -webkit-animation:spin 4s linear infinite;
    -moz-animation:spin 4s linear infinite;
    animation:spin 4s linear infinite;
}
@-moz-keyframes spin { 100% { -moz-transform: rotate(360deg); } }
@-webkit-keyframes spin { 100% { -webkit-transform: rotate(360deg); } }
@keyframes spin { 100% { -webkit-transform: rotate(360deg); transform:rotate(360deg); } }

.vue-next-typeahead__wrapper-input:hover:not(.vue-next-typeahead__wrapper-input--focusing) {
    background: #FAFAFA;
    border: 1px solid #9B9B9B;
}

.vue-next-typeahead__wrapper-input:hover:not(.vue-next-typeahead__wrapper-input--focusing) > input::placeholder {
    color: #9B9B9B;
}

.vue-next-typeahead__wrapper-input--focusing {
    box-shadow: 0px 0px 8px 0px #FF7300 20%;
    border: 1px solid #FF7300;
    box-sizing: border-box;
    box-shadow: 0px 0px 8px rgba(255, 115, 0, 0.2);
}
.vue-next-typeahead__wrapper-input--focusing .ico-search {
    background-image: url('../assets/search-orange.svg');
}

.vue-next-typeahead__dropdown {
    border: 1px solid #D2D2D2;
    list-style: none;
    width: calc(100% - 2px);
    padding: 16px 0 0;
    margin: -14px 0 0 0;
    max-height: 336px;
    overflow-y: auto;
}

.vue-next-typeahead__dropdown > li {
    min-height: 42px;
    padding: 0 16px;
    font-size: 16px;
    font-style: normal;
    letter-spacing: 0px;
    text-align: left;
    cursor: pointer;
}

.vue-next-typeahead__dropdown > li:hover {
    background: #FAFAFA;
}

.vue-next-typeahead__dropdown > li > span {
    line-height: 42px;
}

.vue-next-typeahead__dropdown > li.li-no-results {
    line-height: 42px;
    cursor: auto;
}

.vue-next-typeahead__dropdown::-webkit-scrollbar {
    -webkit-appearance: none;
    width: 5px;
    height: 6px;
}

.vue-next-typeahead__dropdown::-webkit-scrollbar-thumb {
    border-radius: 12px;
    border: 4px solid rgba(255, 255, 255, 0);
    background-color: #bdbdbd;
}

.vue-next-typeahead__dropdown::-webkit-scrollbar-corner {
    background-color: transparent;
}

@media screen and (max-width: 768px) {
.vue-next-typeahead {
    width: 100%;
}
}
</style>

<script>
    function start(){
        const { ref, computed } = Vue;
        const app = Vue.createApp({
            setup() {
                const features = ref([{
                    name: 'User Registration',
                    description: 'All scenarios around registering and verifying a new web account',
                    scenarios: [{
                        title: 'user registers web account',
                        given: ['user is on the registration page'],
                        when: ['user enters their details'],
                        then: ['user is registered']
                    },{
                        title: 'user sees validation errors when submitting bad data to registration form',
                        given: ['user is on the registration page'],
                        when: ['user enters invalid details'],
                        then: ['user sees validation errors']
                    },{
                        title: 'user gets duplicate email error when registering with an email that already exists',
                        given: ['user account exists for email'],
                        when: ['user enters an email that already exists'],
                        then: ['user sees duplicate email error in email inbox']
                    },{
                        title: 'user gets verification email after registering',
                        given: ['user submitted web account registration form'],
                        when: ['user checks email'],
                        then: ['user sees verification email']
                    },{
                        title: 'user clicks verification link in email',
                        given: ['user received verification email'],
                        when: ['user clicks verification link'],
                        then: ['user is verified']
                    }]
                },{
                    name: 'User Password Actions',
                    description: 'All scenarios around changing and resetting a user\'s password',
                    scenarios: [{
                        title: 'user forgets password, requests reset',
                        given: ['user is on the login page'],
                        when: ['user clicks forgot password link and submits email address'],
                        then: ['user receives password reset email']
                    },{
                        title: 'user clicks password reset link in email',
                        given: ['user received password reset email'],
                        when: ['user clicks password reset link'],
                        then: ['user is taken to password reset page']
                    },{
                        title: 'user resets password',
                        given: ['user is on the password reset page'],
                        when: ['user enters new password and submits form'],
                        then: ['user is logged in']
                    },{
                        title: 'user changes password',
                        given: ['user is logged in'],
                        when: ['user clicks change password link and submits form'],
                        then: ['user is logged in']
                    },{
                        title: 'user visits reset password page with invalid token',
                        given: ['user is on the password reset page'],
                        when: ['user enters new password and submits form'],
                        then: ['user sees invalid token error']
                    }]
                }])
                const newScenarioNameInput = ref('');
                const selectedFeatureIndex = ref(0);
                const selectedScenarioIndex = ref(0);
                const showDeleteModal = ref(false);

                const addScenario = () => {
                    console.warn('addScenario: newScenarioNameInput.value:', newScenarioNameInput.value);
                    console.warn('addScenario: selectedFeature:', selectedFeature.value);
    
                    if(selectedFeature == null){
                        console.warn("addScenario: selectedFeature is null");
                        return;
                    }
                    if (newScenarioNameInput.value) {
                        features.value[selectedFeatureIndex.value].value.scenarios.push({ 
                            title: newScenarioNameInput.value, 
                            given: [], 
                            when: [], 
                            then: [] 
                        });
                        newScenarioNameInput.value = '';
                    }else{
                        console.warn("addScenario: newScenario is null");
                    }
                };

                const selectFeatureIndex = (featureIndex) => {
                    if(!features.value[featureIndex]){
                        console.warn("selectFeatureIndex: featureIndex is null");
                        return;
                    }
                    selectedFeatureIndex.value = featureIndex;
                };

                const selectScenarioIndex = (scenarioIndex) => {
                    console.warn('selectScenario: scenario:', scenario);
                    selectScenarioIndex.value = scenarioIndex;
                };

                // Getters (computed) for SelectedFeature and SelectedScenario
                const selectedFeature = computed(() => {
                    const feature = features.value[selectedFeatureIndex.value];
                    console.warn('selectedFeature:', feature);
                    return feature;
                });

                const selectedScenario = computed(() => {
                    const scenario = selectedFeature.value.scenarios[selectedScenarioIndex.value];
                    console.warn('selectedScenario:', scenario);
                    return scenario;
                });

                const searchableFeatureNames = computed(() => {
                    return features.value.map(feature => feature.name);
                });

                const searchableScenarioNames = computed(() => {
                    const values = [];
                    // loop through ALL features > scenarios and collect into a unique set
                    features.value.forEach(feature => {
                        feature.scenarios.forEach(scenario => {
                            if(!values.some(value => value.name === scenario.title)){
                                values.push({
                                    name: scenario.title,
                                });
                            }
                        });
                    });
                    return values;
                });

                const searchableGivenNames = computed(() => {
                    const values = [];
                    // loop through ALL features > scenarios > given and collect into a unique set
                    features.value.forEach(feature => {
                        feature.scenarios.forEach(scenario => {
                            scenario.given.forEach(given => {
                                if(!values.some(value => value.name === given)){
                                    values.push({
                                        name: given,
                                    });
                                }
                            });
                        });
                    });
                    return values;
                });
                const searchableWhenNames = computed(() => {
                    const values = [];
                    // loop through ALL features > scenarios > when and collect into a unique set
                    features.value.forEach(feature => {
                        feature.scenarios.forEach(scenario => {
                            scenario.when.forEach(when => {
                                if(!values.some(value => value.name === when)){
                                    values.push({
                                        name: when,
                                    });
                                }
                            });
                        });
                    });
                    return values;
                });
                const searchableThenNames = computed(() => {
                    const values = [];
                    // loop through ALL features > scenarios > then and collect into a unique set
                    features.value.forEach(feature => {
                        feature.scenarios.forEach(scenario => {
                            scenario.then.forEach(then => {
                                if(!values.includes(then)){
                                    values.push({
                                        name: then,
                                    });
                                }
                            });
                        });
                    });
                    return values;
                });

                const deleteScenario = () => {
                    if(selectedFeatureIndex === null){
                        console.warn("deleteScenario: selectedFeatureIndex is null");
                        return;
                    }
                    if(selectedScenarioIndex === null){
                        console.warn("deleteScenario: selectedScenarioIndex is null");
                        return;
                    }
                    if(!scenarios.value[selectedScenarioIndex.value]){
                        console.warn("deleteScenario: scenarios[selectedScenarioIndex] is null");
                        return;
                    }
                    features.value[selectedFeatureIndex.value].value.scenarios.splice(selectedScenarioIndex.value, 1);
                    showDeleteModal.value = false;
                };

                const endDrag = () => {
                    // Handle drag end event
                    console.warn('handle drag end',arguments);
                };

                const featureSelectorInput = ref('');

                return {
                    scenarios: selectedFeature?.value?.scenarios ?? [],
                    featureSelectorInput,
                    searchableFeatureNames,
                    searchableScenarioNames,
                    searchableGivenNames,
                    searchableWhenNames,
                    searchableThenNames,
                    newScenarioNameInput,
                    selectedFeature,
                    selectedScenario,
                    selectedFeatureIndex,
                    selectedScenarioIndex,
                    showDeleteModal,
                    addScenario,
                    selectFeatureIndex,
                    selectScenarioIndex,
                    deleteScenario,
                    endDrag
                };
            }
        });
        app.component('draggable', window.vuedraggable)
        //console.warn('registering VueNextTypeahead', window.VueNextTypeahead);
        app.component('vue-typeahead', window.VueNextTypeahead)
        // FeatureSelector
        app.component('feature-selector', {
            template: '#feature-selector-template',
            data(){
                return {
                    searching: false
                }
            },
            props: ['featureSelectorInput', 'selectedFeature', 'features', 'updateFeature', 'searchableFeatureNames'],
            methods:{
                onSearchingStateChanged: function(isSearching){
                    console.warn('onSearchingStateChanged', isSearching);
                    this.searching = isSearching;
                }
            },
            mounted(){
                console.warn('FeatureSelector: featureSelectorInput:', {
                    featureSelectorInput: this.featureSelectorInput,
                    selectedFeature: this.selectedFeature,
                    features: this.features,
                    updateFeature: this.updateFeature,
                    searchableFeatureNames: this.searchableFeatureNames
                });
            }
        });
        // ScenarioList
        app.component('scenario-list', {
            template: '#scenario-list-template',
            props: ['scenarios', 'newScenario', 'addScenario', 'selectScenarioIndex', 'endDrag'],
            data(){
                console.warn('what props do i have? ', JSON.parse(JSON.stringify(this.$props)))
                return {}
            },
            mounted(){
                console.warn('ScenarioList: scenarios:', this.scenarios);
                console.warn('ScenarioList: newScenario:', this.newScenario);
                console.warn('ScenarioList: addScenario:', this.addScenario);
                console.warn('ScenarioList: selectScenarioIndex:', this.selectScenarioIndex);
                console.warn('ScenarioList: endDrag:', this.endDrag);
            }
        });
        // ScenarioDetails
        app.component('scenario-details', {
            template: '#scenario-details-template',
            props: [
                'selectedScenario', 
                'showDeleteModal', 
                'searchableGivenNames', 
                'searchableWhenNames',
                'searchableThenNames'
            ]
        });
        app.component('delete-modal', {
            template: '#delete-modal-template',
            props: ['showDeleteModal', 'deleteScenario']
        });
        
        app.mount('#app');
    }
    document.addEventListener('DOMContentLoaded', start);
</script>
</body>