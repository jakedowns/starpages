<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gherkin Test Manager</title>
    
    <script src="https://unpkg.com/vue@3.3.13"></script>
    <script src="https://unpkg.com/sortablejs@1.10.2"></script>
    <script src="https://unpkg.com/vuedraggable@4.0.1"></script>
    <!-- <script src="https://unpkg.com/vue-next-typeahead@0.0.2"></script> -->

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Open Sans', sans-serif;
            background-color: #111;
        }
        .clearfix {
            clear: both;
            overflow: auto;
        }
        input {
            color: #fff;
            background-color: #222;
        }
        .fixed-top {
            position: fixed;
            top: 0;
            left: 0;
            width: 33.3333%;
            background-color: #fff; /* Light theme */
            border-right: 1px solid #e5e7eb; /* Light theme border */
        }

        .left-panel {
            margin-top: /* Height of the .fixed-top element */;
            width: 33.3333%;
            height: calc(100% - /* Height of the .fixed-top element */);
            overflow-y: auto;
        }

        .main-content {
            width: 66.6667%;
            /* Other styles */
        }
        .caret-down::after {
            pointer-events: none;
            content: '▼';
            position: absolute;
            right: 20px;
            top: 17px;
            z-index: 1;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 10;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgb(0,0,0);
            background-color: rgba(0,0,0,0.4);
            padding-top: 60px;
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
    </style>
    <script>
        window.unwrap = function(obj){
            const seen = new WeakSet();
            return JSON.parse(JSON.stringify(obj, (key, value) => {
                if (typeof value === "object" && value !== null) {
                    if (seen.has(value)) {
                        return;
                    }
                    seen.add(value);
                }
                return value;
            }));
        }
    </script>
</head>
<body class="">

<div id="app" class="flex-row p-4 h-screen overflow-hidden">
    <feature-selector
        :selected-feature-index="selectedFeatureIndex"
        :selected-feature="selectedFeature"
        :features="features"
        :searchable-feature-names="searchableFeatureNames"
        :select-feature-index="selectFeatureIndex"
    ></feature-selector>
    <div class="flex">
        <div class="w-1/2">
            <scenario-list 
                :add-scenario="addScenario"
                :scenarios="scenarios"
                :select-scenario-index="selectScenarioIndex"
                :selected-scenario-index="selectedScenarioIndex"
                :end-drag="endDrag"
            ></scenario-list>
        </div>
        <div class="w-1/2 overflow-y-auto overflow-x-hidden">
            <scenario-details v-if="selectedScenario"
                :selected-scenario="selectedScenario"
                :selected-scenario-index="selectedScenarioIndex"
                :searchable-given-names="searchableGivenNames"
                :searchable-when-names="searchableWhenNames"
                :searchable-then-names="searchableThenNames"
            ></scenario-details>
        </div>
    </div>
    
    
    <delete-modal v-if="showDeleteModal"></delete-modal>
</div>

<!-- Feature Selector is a type-head text field that doubles as a H1 header for the selected Feature as well as an input that allows you to fuzzy-search to switch the selected feature, and there's always a default option to "Create New Feature Named... %whatever the user was typing%" -->
<!-- FeatureSelector -->
<script type="text/x-template" id="feature-selector-template">
    <div class="w-full feature-selector z-11">
        <vue-typeahead
            placeholder="Feature Name..."
            :backingData="searchableFeatureNames"
            :items="features"
            :minChars="1"
            :show-dropdown-on-focus="true"
            :class="{'text-2xl font-bold mb-4': true}"
            :v-model="featureSelectorInput"
            @searching="onSearchingStateChanged"
            @filtered-options-updated="onFeatureSelectorResultsUpdated"
            @reset="onFeatureSelectorReset"
            @select="onFeatureSelectorSelect"
            @focus="onFocusIn"
            @blur="onFocusOut"
        ></vue-typeahead>
    </div>
</script>


<!-- ScenarioList -->
<script type="text/x-template" id="scenario-list-template">
    <div class="overflow-y-auto h-screen relative z-9">
        <div class="absolute w-full top-12">
            <input type="text" placeholder="New Scenario Name..." class="text-white w-full p-2 border rounded caret-down relative" v-model="newScenarioNameInput" @keyup.enter="addScenario" />
        </div>
        <!--
            "Actions" button group 
            > Run All Scenarios
            > Stop All Scenarios
            a tailwind-styled, bootstrap _inspired_ dropdown button where you hover and it gives you more options
            for mobile accessibility tapping it should show/hide the dropdown 
        -->
        
        <div class="pt-4 block relative">
            <div class="">
                <h2>Scenarios</h2>
            </div>
            <div class="group absolute left-auto right-0 z-9 w-auto top-0">
                <button class="bg-blue-500 text-white font-bold py-2 px-4 rounded ">Actions &#9660;</button>
                <div class="absolute left-0 top-10 overflow-auto rounded-md shadow-lg py-1 bg-white hidden group-hover:flex flex-col shadow w-40 -ml-20" 
                role="menu" 
                aria-orientation="vertical" 
                aria-labelledby="options-menu">
                    <button class="w-full text-left block px-4 py-2 text-sm text-gray-700 hover:bg-blue-500 hover:text-white" role="menuitem"><span style="color:white;">&#9658;</span> Run All Scenarios</button>
                    <button class="w-full text-left block px-4 py-2 text-sm text-gray-700 hover:bg-red-500 hover:text-white" role="menuitem">&#x1F6D1; Stop All Scenarios</button>
                </div>
            </div>
        </div>
        


        <div v-if="scenarios?.length" class="pt-20 pb-12">
            
            <!-- Scenarios:
            <pre>{{ scenarios }}</pre> -->
            <!-- <pre>#scenarios:{{scenarios?.length}}
#selectedScenarioIndex:{{selectedScenarioIndex}}
            </pre> -->
            <draggable class="space-y-2" :item-key="'blah'" v-model="scenarios" @end="endDrag">
                <template #item="{element, index}">
                    <div :key="index" 
                    class="p-2 border rounded cursor-pointer"
                    :class="[
                    selectedScenarioIndex === index ? 'bg-purple-900 text-white' : 'bg-black-10 text-white'
                    ]"
                        @click="selectScenarioIndex(index)">
                        {{ index + 1 }}) {{ element.title }}
                    </div>
                </template>
            </draggable>
        </div>
    </div>
</script>

<!-- ScenarioDetails -->
<script type="text/x-template" id="scenario-details-template">
    <div class="w-full ml-4 p-4 h-screen overflow-y-auto">
        <!-- <span>Selected Scenario:</span>
        <h1 class="text-l font-bold mb-4 text-white">{{selectedScenarioIndex + 1}}) {{ selectedScenario?.title ?? 'No Scenario Selected' }}</h1> -->
        <div class="overflow-hidden space-x-2 mb-4">
            <!-- todo: hide if running? -->
            <button class="w-auto text-left inline-block px-4 py-2 text-sm bg-blue-500 hover:bg-blue-700 text-white rounded" role="menuitem"><span style="color:white;">&#9658;</span> Run Scenario</button>
            <!-- todo: show if running -->
            <button class="w-auto text-left inline-block px-4 py-2 text-sm bg-red-500 hover:bg-red-700 text-white rounded" role="menuitem">&#x1F6D1; Stop Scenario</button>
        </div>
        <div v-if="!selectedScenario">
            <p>Select a scenario to view details</p>
        </div>
        <div v-if="selectedScenario">
            <div class="mb-4" v-for="(item, index) in selectedScenario.given" :key="'given-' + index">
                <label class="block text-cyan-700">Given</label>
                <vue-typeahead
                    :v-model="item"
                    :backingData="searchableGivenNames"
                    :minChars="1"
                    placeholder="given..."
                    class="given-input w-full p-2 border rounded caret-down relative"
                ></vue-typeahead>
            </div>
            <div class="mb-4" v-for="(item, index) in selectedScenario.when" :key="'when-' + index">
                <label class="block text-blue-700">When</label>
                <vue-typeahead
                    :v-model="item"
                    :backingData="searchableWhenNames"
                    :minChars="1"
                    placeholder="when..."
                    class="when-input w-full p-2 border rounded caret-down relative"
                ></vue-typeahead>
            </div>
            <div class="mb-4" v-for="(item, index) in selectedScenario.then" :key="'then-' + index">
                <label class="block text-orange-700">Then</label>
                <vue-typeahead
                    :v-model="item"
                    :backingData="searchableThenNames"
                    :minChars="1"
                    placeholder="then..."
                    class="then-input w-full p-2 border rounded caret-down relative"
                ></vue-typeahead>
            </div>
            <button id="deleteBtn" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded" @click="showDeleteModal = true">Delete</button>
            <h4>Scenario Run History:</h4>
            <div>TODO!</div>
        </div>
    </div>
</script>

<script type="text/x-template" id="delete-modal-template">
    <div id="myModal" class="modal">
        <div class="modal-content">
            <span class="close" @click="showDeleteModal = false">&times;</span>
            <p>Are you sure you want to delete this scenario?</p>
            <button class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded" @click="deleteScenario">Yes</button>
            <button class="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded" @click="showDeleteModal = false">No</button>
        </div>
    </div>
</script>

<!-- #vue-typeahead-template -->
<script type="text/x-template" id="vue-typeahead-template">
    <div :class="className">
        <input type="text" class="w-full p-2 border rounded caret-down relative" 
            :class="{'bg-blue-200': searching}"
            :placeholder="placeholder"
            name="garbage"
            autocomplete="off"
            :value="vModel"
            @focus="onFocusIn"
            @blur="onFocusOut"
            @input="onTypeaheadValueInput" />
        <div class="relative">
            <ul class="overflow-y-auto h-screen absolute left-0 z-10 w-full bg-white border rounded shadow-lg" v-if="showDropdown && items.length > 0">
                <li class="clearfix"><div class="float-left">Features:</div><div class="float-right">Status:</div></li>
                <li class="p-2 hover:bg-blue-100 cursor-pointer clearfix"
                    :class="{ 'bg-blue-200': index === highlightedOptionIndex }"
                    v-for="(item, index) in items" :key="index" @click="$emit('select', index)">
                    <div class="float-left">{{index+1}}) {{ item.name }}</div>
                    <div class="float-right">✅</div>
                </li>
                <li class="p-2 hover:bg-blue-100 cursor-pointer" @click="$emit('select', 'new_feature')">
                    New Feature{{ vModel.length ? ' '+vModel : '' }}...
                </li>
            </ul>
        </div>
    </div>
</script>


<script>
    window.VueNextTypeahead = {
        name: 'vue-typeahead',
        template: "#vue-typeahead-template",
        props: {
            showDropdownOnFocus: {
                type: Boolean,
                default: true
            },
            apiUrl: {
                type: String,
                required: false
            },
            backingData: {
                type: Array,
                required: false
            },
            input: {
                type: String,
                default: ''
            },
            title: {
                type: String,
                default: null
            },
            className: {
                type: String,
                default: ''
            },
            items: {
                type: Array,
                default: () => []
            },
            keyItem: {
                type: String,
                default: null
            },
            showTitle: {
                type: Boolean,
                default: true
            },
            placeholder: {
                type: String,
                default: 'Qué necesitas...'
            },
            noResultsText: {
                type: String,
                default: 'No existen resultados para esa búsqueda...'
            },
            minChars: {
                type: Number,
                default: 2,
                validator: (value) => {
                    return value > 0
                }
            },
            delay: {
                type: Number,
                default: 500
            },
            loadingParentComponent: {
                type: Boolean,
                default: false
            },
            vModel: {
                type: String,
                required: true
            }
        },
        data() {
            return {
                searching: false,
                focusing: false,
                showDropdown: false,
                timeout: '',
                highlightedOptionIndex: 0
            }
        },
        mounted() {
            document.addEventListener('click', (e) => {
                if (!this.$el.contains(e.target)) {
                    this.reset()
                }
            })
        },
        methods: {
            onTypeaheadValueInput(event) {
                //this.$emit('update:vModel', event.target.value)
                if (event.target.value.length >= this.minChars) {
                    this.search()
                }
                if (event.target && event.target.value.length === 0) {
                    this.reset()
                }
            },
            search() {
                this.searching = true
                // emit
                this.$emit('searching', true)
                clearTimeout(this.timeout)
                this.timeout = setTimeout(async () => {
                    try {
                        let response;
                        if (this.backingData && this.backingData.length > 0) {
                            //console.warn('backingData', this.backingData)
                            // Filter the backingData based on the inputLocalCache value
                            response = this.backingData.filter(item => {
                                // item might be an object or a string
                                if(typeof item === 'object'){
                                    return item.name.toLowerCase().includes(this.vModel.toLowerCase())
                                }
                                return item.toLowerCase().includes(this.vModel.toLowerCase())
                            });
                            //console.warn('filtered:', response)
                        } else {
                            // Fetch data from the apiUrl
                            response = await fetch(this.apiUrl)
                        }
                        this.$emit('filteredOptionsUpdated', response)
                    } catch (error) {
                        console.error('Error occurred during search:', error);
                        this.$emit('error', error)
                    } finally {
                        clearTimeout(this.timeout)
                        this.showDropdown = true
                        this.searching = false
                        this.$emit('searching', false)
                    }
                }, 0)//this.delay)
            },
            // changeInput(event) {
            //     if (event?.target?.value?.length >= this.minChars) {
            //         this.search()
            //     }
            //     this.$emit('update:input', event.target.value)
            //     if (event.target && event.target.value.length === 0) {
            //         this.reset()
            //     }
            // },
            onFocusIn() {
                this.focused = true
                this.$emit('focus')
                if(this.showDropdownOnFocus){
                    this.search()
                }
            },
            onFocusOut() {
                this.$emit('blur')
                this.focused = false
                this.reset()
            },
            clickItem(item) {
                this.$emit('hit', item)
                this.reset()
            },
            // highlight(text, term) {
            //     if (text && term) {
            //         var index = text.toLowerCase().indexOf(term.toLowerCase())
            //         if (index >= 0) {
            //             text = `${text.substring(0, index)}<span style="font-weight: 600;">${text.substring(index, index + term.length)}</span>${text.substring(index + term.length)}`
            //         }
            //     }
            //     return text
            // },
            reset() {
                console.warn('VueTypeahead: reset');
                this.showDropdown = false
                this.searching = false
                this.$emit('reset')
                //this.$emit('update:input', '')
            }
        }
    }


</script>

<style>
.vue-next-typeahead {
    width: 460px;
    display: block;
    position: relative;
}

.vue-next-typeahead__title {
    font-size: 16px;
    font-style: normal;
    font-weight: 600;
    line-height: 22px;
    letter-spacing: 0px;
    text-align: left;
    display: block;
    margin-bottom: 8px;
}

.vue-next-typeahead__wrapper-input {
    height: 48px;
    background: #FFFFFF;
    border: 1px solid #D2D2D2;
    box-sizing: border-box;
    border-radius: 4px;
    padding: 0 15px 0 16px;
    position: relative;
}

.vue-next-typeahead__wrapper-input > input {
    height: 48px;
    border-radius: 0;
    border: 0;
    outline: none;
    font-size: 16px;
    font-style: normal;
    font-weight: 400;
    line-height: 22px;
    letter-spacing: 0px;
    text-align: left;
    margin-right: 8px;
    width: calc(100% - 32px);
    padding: 0;
    max-height: 100%;
    color: #404040;
    background: transparent;
}

.vue-next-typeahead__wrapper-input > input::placeholder {
    color: #D2D2D2;
}

.vue-next-typeahead__wrapper-input .ico-search,
.vue-next-typeahead__wrapper-input .ico-loader {
    vertical-align: middle;
    background-size: cover;
    display: inline-block;
    width: 24px;
    height: 24px;
}
.vue-next-typeahead__wrapper-input .ico-search {
    background-image: url('../assets/search.svg');
}
.vue-next-typeahead__wrapper-input .ico-loader {
    background-image: url('../assets/loader-orange.svg');
    -webkit-animation:spin 4s linear infinite;
    -moz-animation:spin 4s linear infinite;
    animation:spin 4s linear infinite;
}
@-moz-keyframes spin { 100% { -moz-transform: rotate(360deg); } }
@-webkit-keyframes spin { 100% { -webkit-transform: rotate(360deg); } }
@keyframes spin { 100% { -webkit-transform: rotate(360deg); transform:rotate(360deg); } }

.vue-next-typeahead__wrapper-input:hover:not(.vue-next-typeahead__wrapper-input--focusing) {
    background: #FAFAFA;
    border: 1px solid #9B9B9B;
}

.vue-next-typeahead__wrapper-input:hover:not(.vue-next-typeahead__wrapper-input--focusing) > input::placeholder {
    color: #9B9B9B;
}

.vue-next-typeahead__wrapper-input--focusing {
    box-shadow: 0px 0px 8px 0px #FF7300 20%;
    border: 1px solid #FF7300;
    box-sizing: border-box;
    box-shadow: 0px 0px 8px rgba(255, 115, 0, 0.2);
}
.vue-next-typeahead__wrapper-input--focusing .ico-search {
    background-image: url('../assets/search-orange.svg');
}

.vue-next-typeahead__dropdown {
    border: 1px solid #D2D2D2;
    list-style: none;
    width: calc(100% - 2px);
    padding: 16px 0 0;
    margin: -14px 0 0 0;
    max-height: 336px;
    overflow-y: auto;
}

.vue-next-typeahead__dropdown > li {
    min-height: 42px;
    padding: 0 16px;
    font-size: 16px;
    font-style: normal;
    letter-spacing: 0px;
    text-align: left;
    cursor: pointer;
}

.vue-next-typeahead__dropdown > li:hover {
    background: #FAFAFA;
}

.vue-next-typeahead__dropdown > li > span {
    line-height: 42px;
}

.vue-next-typeahead__dropdown > li.li-no-results {
    line-height: 42px;
    cursor: auto;
}

.vue-next-typeahead__dropdown::-webkit-scrollbar {
    -webkit-appearance: none;
    width: 5px;
    height: 6px;
}

.vue-next-typeahead__dropdown::-webkit-scrollbar-thumb {
    border-radius: 12px;
    border: 4px solid rgba(255, 255, 255, 0);
    background-color: #bdbdbd;
}

.vue-next-typeahead__dropdown::-webkit-scrollbar-corner {
    background-color: transparent;
}

@media screen and (max-width: 768px) {
.vue-next-typeahead {
    width: 100%;
}
}
</style>

<script>
    function start(){
        const { ref, toRefs, computed, reactive, readonly } = Vue;
        const state = reactive({
            events: {},
            selectedFeatureIndex: 0,
            newScenarioNameInput: '',
            featureSearchInput: '',
        });
        window.gwt_state = state;

        const EventBus = {
            emit(event, data) {
                if (!state.events[event]) {
                state.events[event] = [];
                }
                state.events[event].push(data);
            },
            on(event, callback) {
                if (!state.events[event]) {
                state.events[event] = [];
                }
                state.events[event].push(callback);
            },
            off(event, callback) {
                if (state.events[event]) {
                const index = state.events[event].indexOf(callback);
                if (index > -1) {
                    state.events[event].splice(index, 1);
                }
                }
            }
        };
        // freeze the EventBus object so it can't be modified
        const MainEventBus = readonly(EventBus);
        window.gwt_eventbus = MainEventBus;
        const app = Vue.createApp({
            setup() {
                const features = ref([{
                    name: '👤 User Registration',
                    description: 'All scenarios around registering and verifying a new web account',
                    scenarios: [{
                        title: '👤 user registers web account',
                        given: ['user is on the registration page'],
                        when: ['user enters their details'],
                        then: ['user is registered']
                    },{
                        title: '⚠️ user sees validation errors when submitting bad data to registration form',
                        given: ['user is on the registration page'],
                        when: ['user enters invalid details'],
                        then: ['user sees validation errors']
                    },{
                        title: '🔁 user gets duplicate email notice when registering with an email that already exists',
                        given: ['user account exists for email'],
                        when: ['user enters an email that already exists'],
                        then: ['user sees duplicate email notice in email inbox']
                    },{
                        title: '📧 user gets verification email after registering',
                        given: ['user submitted web account registration form'],
                        when: ['user checks email'],
                        then: ['user sees verification email']
                    },{
                        title: '✅ user clicks verification link in email',
                        given: ['user received verification email'],
                        when: ['user clicks verification link'],
                        then: ['user is verified']
                    }]
                },{
                    name: '🗝️ User Authentication: Happy Path',
                    scenarios:[{
                        title: 'user logs in via login page',
                        given: ['user is on the login page'],
                        when: ['user enters their email and password'],
                        then: ['user is logged in']
                    },{
                        title: 'user logs in via main menu',
                        given: ['user is on the home page'],
                        when: ['user submits their email and password into the main menu'],
                        then: ['user is logged in']
                    },{
                        title: 'user logs in via modal',
                        given: ['user sees the login modal'],
                        when: ['user submits their email and password into the modal'],
                        then: ['user is logged in']
                    }]
                },{
                    name: '❌ User Authentication: Edge Cases',
                    scenarios:[{
                        title: 'user submits invalid email/password via login page',
                        given: ['user is on the login page'],
                        when: ['user enters invalid email and password'],
                        then: ['user sees validation errors on the login form']
                    },{
                        title: 'user submits invalid email/password via main menu',
                        given: ['user is on the home page'],
                        when: ['user submits invalid email and password into the main menu'],
                        then: ['user is redirected to login page with validation errors present']
                    },{
                        title: 'user submits invalid email/password via modal',
                        given: ['user sees the login modal'],
                        when: ['user submits invalid email and password into the modal'],
                        then: ['user sees validation errors in the modal']
                    }]
                },{
                    name: '🔑 User Password Actions',
                    description: 'All scenarios around changing and resetting a user\'s password',
                    scenarios: [{
                        title: 'user forgets password, requests reset',
                        given: ['user is on the login page'],
                        when: ['user clicks forgot password link and submits email address'],
                        then: ['user receives password reset email']
                    },{
                        title: 'user clicks password reset link in email',
                        given: ['user received password reset email'],
                        when: ['user clicks password reset link'],
                        then: ['user is taken to password reset page']
                    },{
                        title: 'user resets password',
                        given: ['user is on the password reset page'],
                        when: ['user enters new password and submits form'],
                        then: ['user is logged in']
                    },{
                        title: 'user changes password',
                        given: ['user is logged in'],
                        when: ['user clicks change password link and submits form'],
                        then: ['user is logged in']
                    },{
                        title: 'user visits reset password page with invalid token',
                        given: ['user is on the password reset page'],
                        when: ['user enters new password and submits form'],
                        then: ['user sees invalid token error']
                    }]
                },{
                    name: '🔍 KYC',
                    scenarios:[],
                },{
                    name: '📱 SMS',
                    scenarios:[],
                },{
                    name: '🚫 Banned Users',
                    scenarios:[],
                },{
                    name: '👁️ Watched Lots',
                    scenarios:[],
                },{
                    name: '📝 Sale Registration',
                    scenarios:[],
                },{
                    name: '💰 Pre-sale Bidding',
                    scenarios:[],
                },{
                    name: '📆 Day Of Sale',
                    scenarios:[],
                }])
                const selectedFeatureIndex = ref(0);
                const selectedScenarioIndex = ref(0);
                const showDeleteModal = ref(false);

                const addScenario = () => {
                    console.warn("Global Action: addScenario", arguments); 
                    if(selectedFeature == null){
                        console.warn("addScenario: selectedFeature is null");
                        return;
                    }
                    if (!state.newScenarioNameInput.length) {
                        console.error('cannot add a scenario with no name');
                        return;
                    }
                    if(!features.value[selectedFeatureIndex.value]){
                        console.warn("addScenario: selectedFeatureIndex is null");
                        return;
                    }
                    features.value[selectedFeatureIndex.value].scenarios.push({ 
                        title: state.newScenarioNameInput,
                        given: [''], 
                        when: [''], 
                        then: [''] 
                    });
                    // reset the input to blank
                    window.gwt_state.newScenarioNameInput = '';
                    // set it as the selected scenario
                    selectedScenarioIndex.value = features.value[selectedFeatureIndex.value].scenarios.length - 1;
                    setTimeout(()=>{
                        // focus the first input in the scenario details
                        document.querySelector('.given-input input').focus();
                    },100)
                };

                const selectFeatureIndex = (featureIndex) => {
                    if(!features.value[featureIndex]){
                        console.warn("selectFeatureIndex: featureIndex is null");
                        return;
                    }
                    selectedFeatureIndex.value = featureIndex;
                };

                const selectScenarioIndex = (scenarioIndex) => {
                    //console.warn('selectScenarioIndex: scenarioIndex:', scenarioIndex);
                    selectedScenarioIndex.value = scenarioIndex;
                };

                // Getters (computed) for SelectedFeature and SelectedScenario
                const selectedFeature = computed(() => {
                    const feature = features.value[selectedFeatureIndex.value];
                    //console.warn('selectedFeature:', feature);
                    return feature;
                });

                const selectedScenario = computed(() => {
                    const scenario = selectedFeature.value.scenarios[selectedScenarioIndex.value];
                    //console.warn('selectedScenario:', scenario);
                    return scenario;
                });

                // MainEventBus.on('...', (value) => {
                //     console.warn('...', value);
                //     state.... = value;
                // });

                const searchableFeatureNames = computed(() => {
                    return features.value.map(feature => feature.name);
                });

                const searchableScenarioNames = computed(() => {
                    const values = [];
                    // loop through ALL features > scenarios and collect into a unique set
                    features.value.forEach(feature => {
                        feature.scenarios.forEach(scenario => {
                            if(!values.some(value => value.name === scenario.title)){
                                values.push({
                                    name: scenario.title,
                                });
                            }
                        });
                    });
                    return values;
                });

                const searchableGivenNames = computed(() => {
                    const values = [];
                    // loop through ALL features > scenarios > given and collect into a unique set
                    features.value.forEach(feature => {
                        feature.scenarios.forEach(scenario => {
                            scenario.given.forEach(given => {
                                // if(!values.some(value => value.name === given)){
                                //     values.push({
                                //         name: given,
                                //     });
                                // }
                                if(!values.includes(given)){
                                    values.push(given);
                                }
                            });
                        });
                    });
                    return values;
                });
                const searchableWhenNames = computed(() => {
                    const values = [];
                    // loop through ALL features > scenarios > when and collect into a unique set
                    features.value.forEach(feature => {
                        feature.scenarios.forEach(scenario => {
                            scenario.when.forEach(when => {
                                // if(!values.some(value => value.name === when)){
                                //     values.push({
                                //         name: when,
                                //     });
                                // }
                                if(!values.includes(when)){
                                    values.push(when);
                                }
                            });
                        });
                    });
                    return values;
                });
                const searchableThenNames = computed(() => {
                    const values = [];
                    // loop through ALL features > scenarios > then and collect into a unique set
                    features.value.forEach(feature => {
                        feature.scenarios.forEach(scenario => {
                            scenario.then.forEach(then => {
                                // if(!values.some(value => value.name === then)){
                                //     values.push({
                                //         name: then,
                                //     });
                                // }
                                if(!values.includes(then)){
                                    values.push(then);
                                }
                            });
                        });
                    });
                    return values;
                });

                const deleteScenario = () => {
                    if(selectedFeatureIndex.value === null){
                        console.warn("deleteScenario: selectedFeatureIndex is null");
                        return;
                    }
                    if(selectedScenarioIndex.value === null){
                        console.warn("deleteScenario: selectedScenarioIndex is null");
                        return;
                    }
                    if(!scenarios.value[selectedScenarioIndex.value]){
                        console.warn("deleteScenario: scenarios[selectedScenarioIndex] is null");
                        return;
                    }
                    features.value[selectedFeatureIndex.value].value.scenarios.splice(selectedScenarioIndex.value, 1);
                    showDeleteModal.value = false;
                };

                const endDrag = (thing) => {
                    // Handle drag end event
                    console.warn('handle drag end',{thing:unwrap(thing)});

                    // update scenario's position in the array
                    // thing.oldIndex -> thing.newIndex
                    console.warn(`from ${thing.oldIndex} to ${thing.newIndex}`);

                    if(!features.value[selectedFeatureIndex.value]){
                        console.warn("endDrag: selectedFeatureIndex is null");
                        return;
                    }
                    if(!features.value[selectedFeatureIndex.value].scenarios[thing.oldIndex]){
                        console.warn("endDrag: scenarios[selectedScenarioIndex] is null");
                        return;
                    }

                    let tempThing = features.value[selectedFeatureIndex.value].scenarios[thing.oldIndex];
                    features.value[selectedFeatureIndex.value].scenarios.splice(thing.oldIndex, 1);
                    features.value[selectedFeatureIndex.value].scenarios.splice(thing.newIndex, 0, tempThing);

                    // update selectedScenarioIndex
                    selectedScenarioIndex.value = thing.newIndex;
                };

                const app_stuff = {
                    features,
                    scenarios: selectedFeature?.value?.scenarios ?? [],
                    searchableFeatureNames,
                    searchableScenarioNames,
                    searchableGivenNames,
                    searchableWhenNames,
                    searchableThenNames,
                    selectedFeatureIndex,
                    selectedFeature,
                    selectedScenarioIndex,
                    selectedScenario,
                    showDeleteModal,
                    addScenario,
                    selectFeatureIndex,
                    selectScenarioIndex,
                    deleteScenario,
                    endDrag,
                };
                Object.defineProperty(window, 'gwtapp', {
                    get: () => app_stuff,
                    set: (value) => {
                        console.error('cannot set gwtapp, it is readonly')
                    }
                });
                return app_stuff;
            }
        });
        app.component('draggable', window.vuedraggable)
        //console.warn('registering VueNextTypeahead', window.VueNextTypeahead);
        app.component('vue-typeahead', window.VueNextTypeahead)
        // FeatureSelector
        app.component('feature-selector', {
            template: '#feature-selector-template',
            data(){
                return {
                    searching: false,
                    focused: false
                }
            },
            props: [
                'selectedFeatureIndex',
                'selectedFeature', 
                'features',
                'searchableFeatureNames'
            ],
            methods:{
                onFeatureSelectorResultsUpdated: function(results){
                    console.warn('onFeatureSelectorResultsUpdated', results);
                },
                onFeatureSelectorSelect: function(index){
                    console.warn('onFeatureSelectorSelect', index);
                    //this.$emit('select-feature-index', index);
                },
                onSearchingStateChanged: function(isSearching){
                    //console.warn('onSearchingStateChanged', isSearching);
                    this.searching = isSearching;
                },
                onFeatureSelectorReset: function(){
                    window.gwt_state.newScenarioNameInput = '';
                },
                onFocusIn(){
                    this.focused = true;
                },
                onFocusOut(){
                    this.focused = false;
                }
            },
            computed:{
                featureSelectorInput: {
                    get(){
                        // if we're focused, it's a text input, not a header
                        if(this.focused){
                            return window.gwt_state.featureSearchInput;
                        }
                        // show the currently selected feature (if any)
                        return 'Feature ' + (this.selectedFeatureIndex + 1) + ') ' + this.selectedFeature?.name ?? '';
                        
                    },
                    set(value){
                        window.gwt_state.featureSearchInput = value;
                    }
                }
            },
            mounted(){
                console.warn('FeatureSelector',{
                    $props: this.$props,
                    props: JSON.parse(JSON.stringify(this.$props)),
                    _this: this
                })
                // focus the input
                setTimeout(()=>{
                    document.querySelector('.feature-selector input').focus();
                },100)
            }
        });
        // ScenarioList
        app.component('scenario-list', {
            template: '#scenario-list-template',
            props: [
                'scenarios', 
                'addScenario',
                'selectedScenarioIndex', 
                'selectScenarioIndex', 
                'endDrag',
            ],
            computed:{
                newScenarioNameInput: {
                    get(){
                        return window.gwt_state.newScenarioNameInput;
                    },
                    set(value){
                        window.gwt_state.newScenarioNameInput = value;
                    }
                }
            },
            data(){
                return {
                    showDropdown: false
                }
            },
            mounted(){
                console.warn('ScenarioList',{
                    $props: this.$props,
                    props: JSON.parse(JSON.stringify(this.$props)),
                    _this: this
                })
            }
        });
        // ScenarioDetails
        app.component('scenario-details', {
            template: '#scenario-details-template',
            props: [
                'selectedScenarioIndex',
                'selectedScenario', 
                'showDeleteModal', 
                'searchableGivenNames', 
                'searchableWhenNames',
                'searchableThenNames'
            ],
        });
        app.component('delete-modal', {
            template: '#delete-modal-template',
            props: ['showDeleteModal', 'deleteScenario']
        });
        
        app.mount('#app');
    }
    document.addEventListener('DOMContentLoaded', start);
</script>
</body>