<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Guessing Game</title>
    <!-- p5.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>

    <!-- Import shared data -->
    <script src="./shared/data.js"></script>

    <!-- Socket.io -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.min.js"></script>
    <style>
        html,body {
            background-color: #000;
            color: white;
            font-family: sans-serif;
        }
        .client-count {
            position: absolute;
            top: 0;
            left: 0;
            padding: 10px;
            background-color: #000;
            font-size: 20px;
            
        }
        #ui {
            position: absolute;
            left: 0;
            top: 0;
            padding: 10px;
            background-color: #000;
            border-radius: 100px;
            display: flex;
            flex-direction: column;
        }
        #ui button {
            background-color: #fff;
            border: 0;
            border-radius: 100px;
            padding: 10px;
            margin: 5px;
            cursor: pointer;
        }
        #ui .shape-selector {
            background-color: #fff;
            border: 0;
            border-radius: 100px;
            padding: 10px;
            margin: 5px;
            cursor: pointer;
        }
        #ui .color-selector {
            background-color: #fff;
            border: 0;
            border-radius: 100px;
            padding: 10px;
            margin: 5px;
            cursor: pointer;
        }
        .gamestate {
            position: absolute;
            top: 100px;
            width: 100%;
            text-align: center;
            font-size: 30px;
            color: white;
            background-color: rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div class="gamestate"></div>
    <div id="ui">
        <p>Pick a Shape:</p>
        <button class="shape-selector circle" onclick="pickShape('circle')">Circle</button>
        <button class="shape-selector square" onclick="pickShape('square')">Square</button>
        <button class="shape-selector triangle" onclick="pickShape('triangle')">Triangle</button>

        <p>Pick a Color:</p>
        <button class="color-selector red" onclick="pickColor('red')">Red</button>
        <button class="color-selector green" onclick="pickColor('green')">Green</button>
        <button class="color-selector blue" onclick="pickColor('blue')">Blue</button>
        <button class="color-selector yellow" onclick="pickColor('yellow')">Yellow</button>
    </div>
    <span class="client-count"></span>
    <div id="gameContainer"></div>
    <script>
        window.myClientData = {
                myId: null,
                assignedColor: null,
                shape: null,
            }
        
        // Initialize p5.js
        new p5(p => {
            
            let otherClients = []

            p.setup = function() {
                p.createCanvas(p.windowWidth, p.windowHeight);
            }

            p.draw = function() {
                p.background(10);

                p.fill(255,0,255,100);
                p.ellipse(p.width/2, p.height/2, 50, 50);

                p.fill(window.myClientData.assignedColor ?? p.color(255,0,0));

                
                // Define a scaling constant for position data
                const scale = 100;
                //p.translate(p.width/2, p.height/2);

                let pos = window.myClientData.assignedPosition;

                // switch based on shape
                // Assume 50 as default radius if pos.r is undefined
                let radius = pos.r ?? 50;

                if(window.myClientData.shape === "circle"){
                    p.ellipse(pos.x * scale, pos.y * scale, radius*2, radius*2);
                }
                else if(window.myClientData.shape === "square"){
                    p.rect(pos.x * scale, pos.y * scale, radius*2, radius*2);
                }
                else if(window.myClientData.shape === "triangle"){
                    p.triangle(pos.x * scale, pos.y * scale, pos.x * scale + radius, pos.y * scale + radius, pos.x * scale - radius, pos.y * scale + radius);
                }else{
                    console.warn('no shape assigned', window.myClientData)
                }

                if(otherClients.length === 0){
                    return;
                }

                // draw all other client shape / colors at their own positions
                otherClients.forEach((client) => {
                    if(!client?.assignedColor){
                        console.warn('no assigned color', client)
                        return;
                    }
                    if(!client?.assignedPosition){
                        console.warn('no assigned position', client)
                        return;
                    }
                    if(!client?.shape){
                        console.warn('no assigned shape', client)
                        return;
                    }
                    p.fill(client.assignedColor ?? "red");
                    // Define the shape drawing function based on the client's shape
                    let drawShape;
                    switch(client.shape) {
                        case "circle":
                            drawShape = (x, y, r) => p.ellipse(x, y, r, r);
                            break;
                        case "square":
                            drawShape = (x, y, r) => p.rect(x, y, r, r);
                            break;
                        case "triangle":
                            drawShape = (x, y, r) => p.triangle(x, y, x + r, y + r, x - r, y + r);
                            break;
                        default:
                            console.warn('Invalid shape', client.shape);
                            return;
                    }
                    if(!drawShape){
                        console.warn('no drawShape', client)
                        return;
                    }
                    // Draw the shape at the client's assigned position
                    drawShape(
                        client.assignedPosition.x * scale, 
                        client.assignedPosition.y * scale, 
                        client.assignedPosition.r * scale * 2);
                })
            }

            p.mousePressed = function() {
                let circle = window.myClientData.assignedPosition;
                let d = p.dist(p.mouseX, p.mouseY, circle.x, circle.y);
                if (d < circle.r) {
                    currentColorIndex = (currentColorIndex + 1) % window.data.colors.length;
                    console.log("Circle was clicked. New color index: " + currentColorIndex);
                    socket.emit('message', {
                        type: "circleClicked",
                        colorIndex: currentColorIndex,
                        clientId: window.myClientData.myId
                    });
                } else {
                    console.log("Circle was not clicked.");
                }
            }

            p.windowResized = function() {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
            }

            // Socket.IO connection to the server
            const socket = io('wss://172.27.118.25:8999');

            document.addEventListener('DOMContentLoaded', () => {
                window.pickColor = function(color){
                    console.warn('pickColor', color)
                    socket.emit('message', {
                        type: "pickColor",
                        color,
                        clientId: window.myClientData.myId
                    });
                }
                window.pickShape = function(shape){
                    console.warn('pickShape', shape)
                    socket.emit('message', {
                        type: "pickShape",
                        shape,
                        clientId: window.myClientData.myId
                    });
                }
            })

            var resizeEvent = new Event('resize');
            window.dispatchEvent(resizeEvent);

            socket.on('connect', () => {
                console.log('Connected to the server');
            });

            socket.on('message', (event) => {
                // Handle messages from the server

                // Parse the incoming message as JSON
                let data = JSON.parse(event);

                if(data.type !== "heartbeat"){
                    console.warn(data);
                }

                // If the message has an "id" field, store it as our assigned id
                if (data.type === "id") {
                    console.warn('my original starting data was', data);
                    window.myClientData = { 
                        ...window.myClientData, 
                        ...{
                            myId: data.id,
                            assignedColor: data.assignedColor,
                            assignedPosition: data.assignedPosition,
                            shape: data.shape
                        }
                    }
                    try{
                        // move to assigned position
                        window.myClientData.assignedPosition = data?.assignedPosition ?? window.myClientData.assignedPosition;

                        // set to assigned color
                        currentColorIndex = window.data.colors.indexOf(data.assignedColor);
                    }
                    catch(e){
                        console.error('error setting initial color and position', e)
                    }
                }
                else if(data.type === "clientUpdated"){
                    // loop over otherClients and if we find a clientId match,
                    // update the circle's color and position
                    let found = false;
                    otherClients.forEach((client) => {
                        if(client.clientId === data.clientId){
                            found = true;
                            //console.warn('found a match', client)
                            client.assignedColor = data.assignedColor;
                            client.shape = data.shape;
                            client.assignedPosition = data.assignedPosition;
                        }
                    })
                    // insert if not found
                    if(!found && data.clientId !== window.myClientData.myId){
                        //console.warn('did not find a match', data)
                        otherClients.push(data)
                    }
                }
                else if(data.type === "clientDisconnected"){
                    // remove it from "otherClients"
                    otherClients = otherClients.filter((client) => {
                        return client.clientId !== data.clientId
                    })
                }
                else if(data.type === "clientConnected"){                    
                    otherClients.push(data)
                }
                else if(data.type === "otherClients"){
                    console.warn('otherClients', data)
                    // Merge the existing otherClients array with the new data from the server
                    otherClients = [...otherClients, ...(data?.otherClients ?? [])];
                }
                else if(data.type === "heartbeat"){
                    // update the client count
                    document.querySelector('.client-count').innerHTML = data.clientCount;
                }
                else if(data.type === "reload"){
                    // reload the page
                    window.location.reload();
                }
                else{
                    console.warn('unhandled message', data)
                }
            });

            window.requestReloadAll = function(){
                socket.emit('message', {
                    type: "requestReloadAll",
                    clientId: window.myClientData.myId
                });
            }

            socket.on('disconnect', () => {
                console.log('Disconnected from the server');
            });

            socket.on('error', (error) => {
                console.log('Socket.IO Error: ', error);
            });

            // Add your game logic here
        }, 'gameContainer');
    </script>
</body>
</html>
