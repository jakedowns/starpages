<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexagons</title>
    <script src="https://unpkg.com/p5"></script>
    <script src="https://cdn.jsdelivr.net/npm/ccapture.js-npmfixed@1.1.0/build/CCapture.all.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #000;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <script>
        let LERP_FACTOR = 0.05; // Lerp factor for size

        let jitterSplatRotation = false;
        let uiContainer; // UI container
        let isUiVisible = true; // UI visibility state
        let isFullscreen = false; // Fullscreen state

        let doAnimateColors = 0;
        // need to run animateColors once to compute the colors
        let computedColorsOnce = 0; 
        // Slider Values
        let splatScale = 0.01;

        let drawHexes = 1;
        let reverseDrawOrder = 0;
        let drawSplats = 1;
        let useMouseTarget = 1;
        let useInfinityTarget = 0;
        let animateMinMax = 0;
        let hexSize;
        let effectiveRadiusScale = 1;
        let slider, delaySlider;
        let cols, rows;
        let hexagons = [];
        let animDelay = 50;
        let maxRadScale = 0;
        let minRadScale = 0.9;
        let recording = 0;
        // Create a capturer that exports a WebM video
        var capturer = new CCapture( { format: 'webm', verbose: false, fps: 60 } );
        let _canvas;
        let capturedFrames = 0;
        let capturedFramesDisplay;
        // sometimes we target the mouse, sometimes we target the center of the screen
        let target = {x: 0, y: 0}

        // define a gradient made up of 5 color stops 
        // based on the magma color scheme from python matplotlib
        // https://matplotlib.org/stable/tutorials/colors/colormaps.html
        let magmaGradient;

        // Add a new variable to store the color animation mode
        const COLOR_MODE_VERTICAL = 0;
        const COLOR_MODE_HORIZONTAL = 1;
        const COLOR_MODE_RADIAL = 2;
        const COLOR_MODE_GREYSCALE = 3;
        const COLOR_MODE_MAGMA = 4;
        const MAX_COLOR_MODES_AVAILABLE = 5;
        let myColorMode = COLOR_MODE_MAGMA;

        // Add a button to switch the color animation mode
        let colorModeButton;
        

        /* a cached bitmap Image of a blurred circle */
        let blurSprite;
        let tintedCache = {};
        function makeABlurSprite(){
            // this function makes an ellipse on an offscreen canvas,
            // bakes it to a bitmap, blurs it, and caches it to a sprite
            // we can instance this sprite as many times as we want cheaply
            let blurCanvas = createGraphics(32, 32);
            blurCanvas.clear();
            //blurCanvas.background(255);
            blurCanvas.noStroke();
            blurCanvas.fill(255, 255, 255, 255)
            blurCanvas.circle(blurCanvas.width / 2, blurCanvas.height / 2, blurCanvas.width / 4);
            blurCanvas.filter(BLUR, 5);
            blurSprite = blurCanvas.get();
        }
        let sliders = {}

        function keyPressed() {
            if (key === '/') {
                // Toggle UI visibility
                isUiVisible = !isUiVisible;
                if (isUiVisible) {
                    uiContainer.style('display', 'block');
                    cursor();
                } else {
                    uiContainer.style('display', 'none');
                    noCursor();
                }

                // Toggle fullscreen mode
                isFullscreen = !isFullscreen;
                fullscreen(isFullscreen);
            }
        }

        function setup() {
            makeABlurSprite();

            // derrived from matplotlib magma color scheme
            magmaGradient = [
                { color: color(251, 252, 191) },
                { color: color(254, 201, 141) },
                { color: color(253, 149, 103) },
                { color: color(240, 96, 93) },
                { color: color(205, 63, 112) },
                { color: color(158, 46, 126) },
                { color: color(113, 31, 129) },
                { color: color(67, 15, 117) },
                { color: color(23, 15, 60) },
                { color: color(0, 0, 3) }
            ]

            // Create UI container
            uiContainer = createDiv();
            uiContainer.id('ui-container');
            uiContainer.style('position', 'absolute');
            uiContainer.style('width', '300px');
            uiContainer.style('height', '100vh');
            uiContainer.style('display', 'block');
            uiContainer.style('top', '0');
            uiContainer.style('left', '0');
            uiContainer.style('background-color', 'rgba(0,0,0,0.5)');
            uiContainer.style('backdrop-filter', 'blur(10px)');

            let buttons = [
                { label: 'Toggle MinMax Animation', action: () => { animateMinMax = !animateMinMax; } },
                { label: 'Switch Color Mode', action: () => { myColorMode = (myColorMode + 1) % MAX_COLOR_MODES_AVAILABLE; computedColorsOnce = 0; } },
                { label: 'Toggle Hexes', action: () => { drawHexes = !drawHexes; } },
                { label: 'Toggle Splats', action: () => { drawSplats = !drawSplats; } },
                //{ label: 'Toggle UI', action: () => { isUiVisible = !isUiVisible; } },
                { label: 'Toggle Draw Order', action: () => { reverseDrawOrder = !reverseDrawOrder; } },
                { label: 'Toggle Mouse Target', action: () => { useMouseTarget = !useMouseTarget; } },
                { label: 'Toggle Infinity Target', action: () => { useInfinityTarget = !useInfinityTarget; } },
                { label: 'Start Recording', action: toggleRecording }
            ];

            let buttonY = 20;
            for (let button of buttons) {
                let btn = createButton(button.label);
                btn.position(10, buttonY);
                btn.mousePressed(button.action);
                btn.parent(uiContainer);
                buttonY += 40;
            }

            // add a text overlay that shows the number of capturedFrames
            capturedFramesDisplay = createDiv('0');
            capturedFramesDisplay.parent(uiContainer);
            capturedFramesDisplay.style('font-size', '48px');
            capturedFramesDisplay.style('color', 'white');
            capturedFramesDisplay.style('text-align', 'center');
            capturedFramesDisplay.style('position', 'absolute');
            capturedFramesDisplay.style('right', '20px');
            capturedFramesDisplay.style('top', '20px');
            capturedFramesDisplay.style('text-shadow', '0px 0px 10px black');

            _canvas = createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100); // Using HSB color mode for easier color transitions
            sliders = {
                'splatScale': { label: 'Splat Scale', min: 0.01, max: .2, step: 0.001, value: splatScale, action: (val) => { splatScale = val; } },
                'hexSize': { label: 'Hexagon Size', min: 10, max: 100, value: 30, action: (val) => { hexSize = val; } },
                'effectiveRadiusScale': { label: 'Target Radius Scale', min: 0.01, max: 3, step: 0.01, value: effectiveRadiusScale, action: (val) => { effectiveRadiusScale = val; } },
                'animDelay': { label: 'Animation Delay', min: 10, max: 100, value: animDelay, action: (val) => { animDelay = val; } },
                'minRad': { label: 'Min Radius', min: -1, max: 1, step: 0.01, value: minRadScale ?? 0, action: (val) => { minRadScale = val; } },
                'maxRad': { label: 'Max Radius', min: -1, max: 1, step: 0.01, value: maxRadScale ?? 1, action: (val) => { maxRadScale = val; } }
            };

            let sliderY = buttonY + 10; // start from the max y value of the buttons
            for (let key in sliders) {
                let sld = createSlider(sliders[key].min, sliders[key].max, sliders[key].value, sliders[key].step ?? 0.01);
                sld.position(10, sliderY);
                sld.input(() => sliders[key].action(sld.value()));
                sliders[key].instance = sld;
                sld.parent(uiContainer);
                
                let label = createDiv(sliders[key].label);
                label.position(10, sld.y - 20);
                label.parent(uiContainer);
                label.style('color','white');

                sliderY += 40;
            }
            console.warn('sliders',sliders)

            hexSize = sliders['hexSize'].instance.value();
            createHexGrid();
        }

        function toggleRecording() {
            if(recording){
                capturer.stop();
                capturer.save();
                recording = false;
                // change label to start recording
                this.html('Start Recording');
                
                return;
            }
            // change label to stop recording
            this.html('Stop Recording');

            let countdown = 3;
            let countdownText = createDiv(countdown);
            countdownText.style('font-size', '48px');
            countdownText.style('color', 'white');
            countdownText.style('text-align', 'center');
            countdownText.style('position', 'absolute');
            countdownText.style('top', '50%');
            countdownText.style('left', '50%');
            countdownText.style('transform', 'translate(-50%, -50%)');
            let countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownText.html(countdown);
                } else {
                    countdownText.remove();
                    clearInterval(countdownInterval);
                }
            }, 1000);

            setTimeout(()=>{
                startRecording();
            },3000);
        }

        
        function startRecording(){
            capturer.start();
            recording = true;
            frameCount = 0;
            capturedFrames = 0;
            draw();
        }

        let prevHexSize = null;
        // infinity symbol animation progress
        let t = 0;
        function draw() {
            if(useMouseTarget){
                target.x = mouseX;
                target.y = mouseY;
            }else if(useInfinityTarget){
                // Define the control points for the infinity symbol
                let leftControlX1 = width / 2 - 50, leftControlY1 = height / 2 - 100;
                let leftControlX2 = width / 2 - 150, leftControlY2 = height / 2 + 100;
                let rightControlX1 = width / 2 + 50, rightControlY1 = height / 2 - 100;
                let rightControlX2 = width / 2 + 150, rightControlY2 = height / 2 + 100;

                // Update t for motion
                t += 0.005;
                if (t > 1) {
                    t = 0;
                }

                // Calculate the position of the red dot
                let dotX, dotY;
                let u = t <= 0.5 ? t * 2 : (t - 0.5) * 2;
                let u2 = u * u, u3 = u2 * u;

                // The segments are being normalized for linear motion to ensure that the motion of the dot follows a smooth, continuous path along the infinity symbol.
                // This is achieved by using a cubic Bezier curve formula, where 'u' is the normalized time (ranging from 0 to 1).
                // The first half of the infinity symbol is defined by the left control points, and the second half by the right control points.
                if (t <= 0.5) {
                    // First half of the infinity symbol
                    dotX = (1 - 3 * u + 3 * u2 - u3) * width / 2 + (3 * u - 6 * u2 + 3 * u3) * leftControlX1 + (3 * u2 - 3 * u3) * leftControlX2 + u3 * width / 2;
                    dotY = (1 - 3 * u + 3 * u2 - u3) * height / 2 + (3 * u - 6 * u2 + 3 * u3) * leftControlY1 + (3 * u2 - 3 * u3) * leftControlY2 + u3 * height / 2;
                } else {
                    // Second half of the infinity symbol
                    dotX = (1 - 3 * u + 3 * u2 - u3) * width / 2 + (3 * u - 6 * u2 + 3 * u3) * rightControlX1 + (3 * u2 - 3 * u3) * rightControlX2 + u3 * width / 2;
                    dotY = (1 - 3 * u + 3 * u2 - u3) * height / 2 + (3 * u - 6 * u2 + 3 * u3) * rightControlY1 + (3 * u2 - 3 * u3) * rightControlY2 + u3 * height / 2;
                }
                target.x = dotX;
                target.y = dotY;
            }else{
                // set target to center of screen
                target.x = width / 2;  
                target.y = height / 2;
            }

            background(10);

            capturedFramesDisplay.html(capturedFrames);

            if(animateMinMax){
                // use sin wave to modulate maxRadScale between 0 and 2
                maxRadScale = map(sin(frameCount * 0.01), -1, 1, 0, 2);
                // modulate minRadScale between 0.9 and 0
                minRadScale = map(sin(frameCount * 0.01), -1, 1, 0.9, 0);
            }else{
                // use the slider values
                maxRadScale = sliders['maxRad'].instance.value();
                minRadScale = sliders['minRad'].instance.value();
            }

            // Calculate effective radius based on 25% of the shortest window edge length
            let effectiveRadius = 0.25 * min(windowWidth, windowHeight) * effectiveRadiusScale;

            // Update each hexagon's target size based on mouse distance
            for (let hex of hexagons) {
                let d = dist(target.x, target.y, hex.x, hex.y);
                //if (d < effectiveRadius) {
                    let sizeFactor = map(d, 0, effectiveRadius, maxRadScale, minRadScale); // Scale factor: 2 at center, 1 at edge
                    hex.targetSize = hexSize * sizeFactor;
                // } else {
                //     hex.targetSize = hexSize;
                // }
            }

            // sort hexagons by distance from target (furthest should be drawn first so they're at the bottom)
            hexagons.sort((a, b) => {
                let distA = dist(target.x, target.y, a.x, a.y);
                let distB = dist(target.x, target.y, b.x, b.y);
                return reverseDrawOrder ? distA - distB : distB - distA;
            });

            // Redraw hexagons and animate colors
            if (hexSize !== prevHexSize) {
                prevHexSize = hexSize;
                createHexGrid(); // Recreate grid if size changes
            }
            //animDelay = delaySlider.value();
            drawHexGrid();
            animateColors();

            if(recording){
                capturedFrames++;
                try {
                    capturer.capture( _canvas.elt );
                } catch (error) {
                    console.log(error);
                }

                //requestAnimationFrame(draw);
            }
        }


        function createHexGrid() {
            hexagons = [];
            let hexHeight = sqrt(3) * hexSize;
            cols = int(width / (1.5 * hexSize));
            rows = int(height / hexHeight);
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    let x = 1.5 * col * hexSize + hexSize;
                    let y = hexHeight * row;
                    if (col % 2 === 1) {
                        y += hexHeight / 2;
                    }
                    hexagons.push(new Hexagon(x, y, hexSize, row, col));
                }
            }
        }

        function drawSplatForHex(hex){
            // draw a copy of the blur sprite as a shadow
            push();
            // change draw mode to center
            imageMode(CENTER);
            translate(hex.x, hex.y);
            scale(hex.size * splatScale);

            
            let TINT_HUE_QUANTIZATION = 2;
            let hue = map(hex.row, 0, rows, 0, 360);
            // push the hue foward constantly and make sure it wraps around
            hue = (hue + (frameCount * 2)) % 360;
            hue = Math.round(hue / TINT_HUE_QUANTIZATION) * TINT_HUE_QUANTIZATION;
            let colorKey = `${hue}`;
            if(!tintedCache[colorKey]){
                let sat = 100; // Keep saturation constant
                let bri = 100; // Keep brightness constant
                let tinted = color(hue, sat, bri);
                // Save a copy of the tinted image to avoid re-tinting
                tintedImage = createImage(blurSprite.width, blurSprite.height);

                // clone the blurSprite pixels
                tintedImage.copy(blurSprite, 0, 0, blurSprite.width, blurSprite.height, 0, 0, blurSprite.width, blurSprite.height);

                
                let d = dist(target.x, target.y, hex.x, hex.y);
                let alpha = map(d, 0, width, 255, 0); // Alpha based on distance from mouse

                tintedImage.loadPixels();
                for (let i = 0; i < tintedImage.pixels.length; i += 4) {
                    let r = tintedImage.pixels[i];
                    let g = tintedImage.pixels[i + 1];
                    let b = tintedImage.pixels[i + 2];
                    let a = tintedImage.pixels[i + 3];

                    // Blend with existing pixel value
                    tintedImage.pixels[i] = red(tinted); // R value
                    tintedImage.pixels[i + 1] = green(tinted); // G value
                    tintedImage.pixels[i + 2] = blue(tinted); // B value
                    tintedImage.pixels[i + 3] = a; // A value based on the existing A value
                }
                tintedImage.updatePixels();

                tintedCache[colorKey] = tintedImage;
            }

            // apply a random rotation to give some noise
            if(jitterSplatRotation){
                rotate(random(0, TWO_PI));
            }

            image(tintedCache[colorKey], 0, 0);
            pop();
        }

        function drawHexGrid() {
            for (let hex of hexagons) {
                hex.updateSize();
                if(drawSplats){
                    drawSplatForHex(hex)
                }
                if(drawHexes){
                    // draw the bestagon
                    hex.draw();
                }
            }
        }

        function animateColors() {
            // if(!doAnimateColors){
            //     if(!computedColorsOnce){
            //         computedColorsOnce = 1;
            //     }else{
            //         return;
            //     }
            // };
            let maxDelay = rows * animDelay;
            if (myColorMode === COLOR_MODE_VERTICAL) { // Vertical hue shift
                for (let hex of hexagons) {
                    let delay = hex.row * animDelay;
                    let colorTime = (frameCount - delay) % maxDelay;
                    let hue = map(colorTime, 0, maxDelay, 0, 360);
                    hex.color = color(hue, 80, 100);
                }
            } else if (myColorMode === COLOR_MODE_HORIZONTAL) { // Horizontal hue shift
                maxDelay = cols * animDelay;
                for (let hex of hexagons) {
                    let delay = hex.col * animDelay;
                    let colorTime = (frameCount - delay) % maxDelay;
                    let hue = map(colorTime, 0, maxDelay, 0, 360);
                    hex.color = color(hue, 80, 100);
                }
            } else if (myColorMode === COLOR_MODE_RADIAL) { // Radial hue shift
                let maxDist = min(width, height) / 2;
                maxDelay = maxDist * animDelay;
                for (let hex of hexagons) {
                    let d = dist(target.x, target.y, hex.x, hex.y);
                    let delay = map(d, 0, maxDist, 0, maxDelay);
                    let colorTime = (frameCount - delay) % maxDelay;
                    let hue = map(colorTime, 0, maxDelay, 0, 360);
                    hex.color = color(hue, 80, 100);
                }
            } else if(myColorMode === COLOR_MODE_GREYSCALE){
                let maxDist = min(width, height) / 2;
                for (let hex of hexagons) {
                    let d = dist(target.x, target.y, hex.x, hex.y);
                    let lightness = map(d, 0, maxDist, 100, 0);
                    hex.color = color(0, 0, lightness);
                }
            } else if(myColorMode === COLOR_MODE_MAGMA){
                let maxDist = min(width, height) / 2;
                for (let hex of hexagons) {
                    let d = dist(target.x, target.y, hex.x, hex.y);
                    if(d < 0.0001){
                        d = 0.0001;
                    }
                    // NOTE: this generates a color by interpolating between the color stops in the magmaGradient array
                    let stopPos = map(d, 0, maxDist, 0, 1);
                    let colorIndex = floor(stopPos * (magmaGradient.length - 1));
                    let nextColorIndex = min(colorIndex + 1, magmaGradient.length - 2);
                    let lerpFactor = stopPos * (magmaGradient.length - 1) - colorIndex;
                    lerpFactor = constrain(lerpFactor, 0, 1);
                    if(colorIndex < 0 || colorIndex >= magmaGradient.length || nextColorIndex < 0 || nextColorIndex >= magmaGradient.length){
                        // set to sensible defaults
                        colorIndex = magmaGradient.length - 1;
                        nextColorIndex = magmaGradient.length - 2;
                    }
                    let color1 = magmaGradient[colorIndex].color;// ?? color(0,0,0);
                    let color2 = magmaGradient[nextColorIndex].color;// ?? color(255,0,255);
                    let _color = lerpColor(color1, color2, lerpFactor);
                    // grab one of the two colors at random
                    //let _color = random() > 0.5 ? color1 : color2;

                    // Ensure we're getting integer values for our colors, no floats
                    _color.levels = _color.levels.map(Math.floor);
                    hex.color = _color;
                }
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            createHexGrid(); // Recreate grid for new window size
        }

        class Hexagon {
            constructor(x, y, size, row, col) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.targetSize = size; // New target size property
                this.row = row;
                this.col = col; // Store the column

                this.color = color(0); // Initial color
            }

            updateSize(){
                // Lerp the size towards the target size
                this.size = lerp(this.size, this.targetSize, LERP_FACTOR);
            }

            draw() {
                

                push();
                translate(this.x, this.y);
                fill(this.color);
                //stroke(0);
                noStroke();
                beginShape();
                for (let i = 0; i < TWO_PI; i += TWO_PI / 6) {
                    let x = this.size * cos(i);
                    let y = this.size * sin(i);
                    vertex(x, y);
                }
                endShape(CLOSE);
                pop();
            }
        }

    </script>
</body>

</html>