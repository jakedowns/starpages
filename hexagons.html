<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexagons</title>
    <script src="https://unpkg.com/p5"></script>
    <script src="https://cdn.jsdelivr.net/npm/ccapture.js-npmfixed@1.1.0/build/CCapture.all.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #000;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        /* custom tailwind.css code: for
        
        transition-all
        l-0
        -l-100%
        duration-500
        ease-in-out
        transform
        translate-x-full
        */
        .transition-all {
            transition-property: all;
            transition-timing-function: ease;
            transition-duration: 150ms;
        }
        .l-0 {
            left: 0;
        }
        .-l-100\% {
            margin-left: -100%;
        }
        .duration-500 {
            transition-duration: 500ms;
        }
        .ease-in-out {
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        }
        .transform {
            transform: translateX(0);
            will-change: transform;
        }
        .translate-x-full {
            transform: translateX(100%);
        }
        .\-translate\-x\-full {
            transform: translateX(-100%);
        }

    </style>
</head>

<body>
    <script>
        let LERP_FACTOR = 0.05; // Lerp factor for size

        let jitterSplatRotation = false;
        let uiContainer; // UI container
        let isUiVisible = true; // UI visibility state
        let isFullscreen = false; // Fullscreen state

        let doAnimateColors = 0;
        // need to run animateColors once to compute the colors
        let computedColorsOnce = 0; 
        // Slider Values
        let splatScale = 0.1;

        let drawHexes = 1;
        let sortDrawOrder = 0;
        let reverseDrawOrder = 0;
        let drawSplats = 1;
        let useMouseTarget = 1;
        let useInfinityTarget = 0;
        let animateMinMax = 0;
        let hexSize;
        let effectiveRadiusScale = 1;
        let slider, delaySlider;
        let cols, rows;
        let hexagons = [];
        let animDelay = 50;
        let maxRadScale = 0;
        let minRadScale = 0.9;
        let recording = 0;
        // Create a capturer that exports a WebM video
        var capturer = new CCapture( { format: 'webm', verbose: false, fps: 60 } );
        let _canvas;
        let capturedFrames = 0;
        let capturedFramesDisplay;
        // sometimes we target the mouse, sometimes we target the center of the screen
        let target = {x: 0, y: 0}

        // define a gradient made up of 5 color stops 
        // based on the magma color scheme from python matplotlib
        // https://matplotlib.org/stable/tutorials/colors/colormaps.html
        let magmaGradient;

        // Add a new variable to store the color animation mode
        const COLOR_MODE_VERTICAL = 0;
        const COLOR_MODE_HORIZONTAL = 1;
        const COLOR_MODE_RADIAL = 2;
        const COLOR_MODE_GREYSCALE = 3;
        const COLOR_MODE_BLACK = 4
        const COLOR_MODE_MAGMA = 5;
        const COLOR_MODE_CUSTOM = 6;
        const MAX_COLOR_MODES_AVAILABLE = Math.max(COLOR_MODE_VERTICAL, COLOR_MODE_HORIZONTAL, COLOR_MODE_RADIAL, COLOR_MODE_GREYSCALE, COLOR_MODE_BLACK, COLOR_MODE_MAGMA, COLOR_MODE_CUSTOM);
        let myColorMode = COLOR_MODE_BLACK;

        // Add a button to switch the color animation mode
        let colorModeButton;
        

        /* a cached bitmap Image of a blurred circle */
        let blurSprite;
        let tintedCache = {};
        function makeABlurSprite(){
            // this function makes an ellipse on an offscreen canvas,
            // bakes it to a bitmap, blurs it, and caches it to a sprite
            // we can instance this sprite as many times as we want cheaply
            let blurCanvas = createGraphics(32, 32);
            blurCanvas.clear();
            //blurCanvas.background(255);
            blurCanvas.noStroke();
            blurCanvas.fill(255, 255, 255, 255)
            blurCanvas.circle(blurCanvas.width / 2, blurCanvas.height / 2, blurCanvas.width / 4);
            blurCanvas.filter(BLUR, 5);
            blurSprite = blurCanvas.get();
        }
        let sliders = {}

        function keyPressed() {
            if (key === 'Escape') {
                if (isFullscreen) {
                    fullscreen(false);
                    isFullscreen = false;
                }
            }
            if (key === '/') {
                // Toggle UI visibility
                isUiVisible = !isUiVisible;
                updateUI();

                // Toggle fullscreen mode
                isFullscreen = !isFullscreen;
                fullscreen(isFullscreen);
            }
        }

        function updateUI(){
            let classConfig = {
                '-translate-x-full': isUiVisible
            };

            for (let className in classConfig) {
                uiContainer.elt.classList.toggle(className, classConfig[className]);
            }

            if (isUiVisible) {
                cursor();
            } else {
                noCursor();
            }
        }

        function loadFromLocalStorage(){
            let data = localStorage.getItem('hexagons');
            try {
                if(data){
                    data = JSON.parse(data);
                    splatScale = data.splatScale;
                    drawHexes = data.drawHexes;
                    sortDrawOrder = data.sortDrawOrder;
                    reverseDrawOrder = data.reverseDrawOrder;
                    drawSplats = data.drawSplats;
                    useMouseTarget = data.useMouseTarget;
                    useInfinityTarget = data.useInfinityTarget;
                    animateMinMax = data.animateMinMax;
                    hexSize = data.hexSize;
                    effectiveRadiusScale = data.effectiveRadiusScale;
                    animDelay = data.animDelay;
                    maxRadScale = data.maxRadScale;
                    minRadScale = data.minRadScale;
                    myColorMode = data.myColorMode;
                    jitterSplatRotation = data.jitterSplatRotation;
                }
            } catch (error) {
                console.error('Error parsing data from local storage:', error);
            }
        }

        function saveToLocalStorage(){
            let data = {
                splatScale: splatScale,
                drawHexes: drawHexes,
                sortDrawOrder: sortDrawOrder,
                reverseDrawOrder: reverseDrawOrder,
                drawSplats: drawSplats,
                useMouseTarget: useMouseTarget,
                useInfinityTarget: useInfinityTarget,
                animateMinMax: animateMinMax,
                hexSize: hexSize,
                effectiveRadiusScale: effectiveRadiusScale,
                animDelay: animDelay,
                maxRadScale: maxRadScale,
                minRadScale: minRadScale,
                myColorMode: myColorMode,
                jitterSplatRotation: jitterSplatRotation
            };
            localStorage.setItem('hexagons', JSON.stringify(data));
        }

        function setup() {
            loadFromLocalStorage();
            makeABlurSprite();

            // derrived from matplotlib magma color scheme
            magmaGradient = [
                { color: color(251, 252, 191) },
                { color: color(254, 201, 141) },
                { color: color(253, 149, 103) },
                { color: color(240, 96, 93) },
                { color: color(205, 63, 112) },
                { color: color(158, 46, 126) },
                { color: color(113, 31, 129) },
                { color: color(67, 15, 117) },
                { color: color(23, 15, 60) },
                { color: color(0, 0, 3) }
            ]

            // Create UI container
            uiContainer = createDiv();
            uiContainer.id('ui-container');

            // add classnames
            uiContainer.class('transition-all duration-500 ease-in-out transform');

            uiContainer.style('position', 'absolute');
            uiContainer.style('width', '300px');
            uiContainer.style('height', '100vh');
            uiContainer.style('display', 'block');
            uiContainer.style('top', '0');
            uiContainer.style('left', '0');
            uiContainer.style('background-color', 'rgba(0,0,0,0.5)');
            uiContainer.style('backdrop-filter', 'blur(10px)');

            // add a little TAB to the left side of the screen
            // that you can click when the UI is hidden
            let tab = createDiv();
            tab.id('ui-tab');
            tab.class('transition-all duration-500 ease-in-out transform');
            tab.style('position', 'absolute');
            tab.style('width', '20px');
            tab.style('height', '100px');
            tab.style('display', 'block');
            tab.style('top', 'calc(50vh - 50px)');
            tab.style('left', '0');
            tab.style('background-color', 'rgba(0,0,0,0.5)');
            tab.style('backdrop-filter', 'blur(10px)');
            tab.style('cursor', 'pointer');
            tab.style('z-index', '1000');
            tab.style('border-radius', '10px');
            tab.mousePressed(() => {
                isUiVisible = !isUiVisible;
                updateUI();
            });

            function act(cb){
                return function(){
                    cb();
                    saveToLocalStorage();
                }
            }
            let buttons = {
                'ToggleMinMaxAnimation': { label: 'Toggle MinMax Animation', action: act(() => { animateMinMax = !animateMinMax; }) },
                'SwitchColorMode': { label: 'Switch Color Mode', action: act(() => { 
                    myColorMode = (myColorMode + 1) % MAX_COLOR_MODES_AVAILABLE; computedColorsOnce = 0; 
                    buttons['SwitchColorMode'].instance.html(`Switch Color Mode (${myColorMode})`);
                }) },
                'ToggleHexes': { label: 'Toggle Hexes', action: act(() => { drawHexes = !drawHexes; }) },
                'ToggleSplats': { label: 'Toggle Splats', action: act(() => { drawSplats = !drawSplats; }) },
                'ToggleUI': { label: 'Toggle UI', action: act(() => { isUiVisible = !isUiVisible; updateUI(); }) },
                'ToggleDrawOrder': { label: 'Toggle Draw Order', action: act(() => { reverseDrawOrder = !reverseDrawOrder; }) },
                'ToggleMouseTarget': { label: 'Toggle Mouse Target', action: act(() => { useMouseTarget = !useMouseTarget; }) },
                'ToggleInfinityTarget': { label: 'Toggle Infinity Target', action: act(() => { useInfinityTarget = !useInfinityTarget; }) },
                'StartRecording': { label: 'Start Recording', action: toggleRecording }
            };

            let buttonY = 20;
            for (let key in buttons) {
                let btn = createButton(buttons[key].label);
                btn.position(10, buttonY);
                btn.mousePressed(buttons[key].action);
                btn.parent(uiContainer);
                buttons[key].instance = btn;
                buttonY += 40;
            }

            // add a text overlay that shows the number of capturedFrames
            capturedFramesDisplay = createDiv('0');
            capturedFramesDisplay.parent(uiContainer);
            capturedFramesDisplay.style('font-size', '48px');
            capturedFramesDisplay.style('color', 'white');
            capturedFramesDisplay.style('text-align', 'center');
            capturedFramesDisplay.style('position', 'absolute');
            capturedFramesDisplay.style('right', '20px');
            capturedFramesDisplay.style('top', '20px');
            capturedFramesDisplay.style('text-shadow', '0px 0px 10px black');
            capturedFramesDisplay.style('display', 'none');

            _canvas = createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100); // Using HSB color mode for easier color transitions

            // sdb === save debounced (Calls saveToLocalStorage every 2 seconds)
            function debounce(func, delay) {
                let debounceTimer;
                return function() {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(func, delay);
                }
            }
            const sdb = debounce(saveToLocalStorage, 2000);

            sliders = {
                'splatScale': { label: 'Splat Scale', min: 0.01, max: .2, step: 0.001, value: splatScale, action: (val) => { splatScale = val; sdb(); } },
                'hexSize': { label: 'Hexagon Size', min: 10, max: 100, step:2, value: 30, action: (val) => { hexSize = val; sdb(); } },
                'effectiveRadiusScale': { label: 'Target Radius Scale', min: -3, max: 3, step: 0.01, value: effectiveRadiusScale, action: (val) => { effectiveRadiusScale = val; sdb(); } },
                'animDelay': { label: 'Animation Delay', min: 10, max: 100, value: animDelay, action: (val) => { animDelay = val; sdb(); } },
                'minRad': { label: 'Min Radius', min: -1, max: 1, step: 0.01, value: minRadScale ?? 0, action: (val) => { minRadScale = val; sdb(); } },
                'maxRad': { label: 'Max Radius', min: -1, max: 1, step: 0.01, value: maxRadScale ?? 1, action: (val) => { maxRadScale = val; sdb(); } }
            };

            let sliderY = buttonY + 10; // start from the max y value of the buttons
            for (let key in sliders) {
                let sld = createSlider(sliders[key].min, sliders[key].max, sliders[key].value, sliders[key].step ?? 0.01);
                sld.position(10, sliderY);
                sld.input(() => sliders[key].action(sld.value()));
                sliders[key].instance = sld;
                sld.parent(uiContainer);
                
                let label = createDiv(sliders[key].label);
                label.position(10, sld.y - 20);
                label.parent(uiContainer);
                label.style('color','white');

                sliderY += 40;
            }
            console.warn('sliders',sliders)

            hexSize = sliders['hexSize'].instance.value();
            createHexGrid();
        }

        function toggleRecording() {
            if(recording){
                capturer.stop();
                capturer.save();
                recording = false;
                // change label to start recording
                this.html('Start Recording');
                
                return;
            }
            capturedFramesDisplay.style('display', 'none');
            // change label to stop recording
            this.html('Stop Recording');

            let countdown = 3;
            let countdownText = createDiv(countdown);
            countdownText.style('font-size', '48px');
            countdownText.style('color', 'white');
            countdownText.style('text-align', 'center');
            countdownText.style('position', 'absolute');
            countdownText.style('top', '50%');
            countdownText.style('left', '50%');
            countdownText.style('transform', 'translate(-50%, -50%)');
            let countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownText.html(countdown);
                } else {
                    countdownText.remove();
                    clearInterval(countdownInterval);
                }
            }, 1000);

            setTimeout(()=>{
                startRecording();
            },3000);
        }

        
        function startRecording(){
            capturedFramesDisplay.style('display', 'block');
            capturer.start();
            recording = true;
            frameCount = 0;
            capturedFrames = 0;
            draw();
        }

        let prevHexSize = null;
        // infinity symbol animation progress
        let t = 0;
        function draw() {
            if(useMouseTarget){
                target.x = mouseX;
                target.y = mouseY;
            }else if(useInfinityTarget){
                // Define the control points for the infinity symbol
                let leftControlX1 = width / 2 - 50, leftControlY1 = height / 2 - 100;
                let leftControlX2 = width / 2 - 150, leftControlY2 = height / 2 + 100;
                let rightControlX1 = width / 2 + 50, rightControlY1 = height / 2 - 100;
                let rightControlX2 = width / 2 + 150, rightControlY2 = height / 2 + 100;

                // Update t for motion
                t += 0.005;
                if (t > 1) {
                    t = 0;
                }

                // Calculate the position of the red dot
                let dotX, dotY;
                let u = t <= 0.5 ? t * 2 : (t - 0.5) * 2;
                let u2 = u * u, u3 = u2 * u;

                // The segments are being normalized for linear motion to ensure that the motion of the dot follows a smooth, continuous path along the infinity symbol.
                // This is achieved by using a cubic Bezier curve formula, where 'u' is the normalized time (ranging from 0 to 1).
                // The first half of the infinity symbol is defined by the left control points, and the second half by the right control points.
                if (t <= 0.5) {
                    // First half of the infinity symbol
                    dotX = (1 - 3 * u + 3 * u2 - u3) * width / 2 + (3 * u - 6 * u2 + 3 * u3) * leftControlX1 + (3 * u2 - 3 * u3) * leftControlX2 + u3 * width / 2;
                    dotY = (1 - 3 * u + 3 * u2 - u3) * height / 2 + (3 * u - 6 * u2 + 3 * u3) * leftControlY1 + (3 * u2 - 3 * u3) * leftControlY2 + u3 * height / 2;
                } else {
                    // Second half of the infinity symbol
                    dotX = (1 - 3 * u + 3 * u2 - u3) * width / 2 + (3 * u - 6 * u2 + 3 * u3) * rightControlX1 + (3 * u2 - 3 * u3) * rightControlX2 + u3 * width / 2;
                    dotY = (1 - 3 * u + 3 * u2 - u3) * height / 2 + (3 * u - 6 * u2 + 3 * u3) * rightControlY1 + (3 * u2 - 3 * u3) * rightControlY2 + u3 * height / 2;
                }
                target.x = dotX;
                target.y = dotY;
            }else{
                // set target to center of screen
                target.x = width / 2;  
                target.y = height / 2;
            }

            background(0);

            capturedFramesDisplay.html(capturedFrames);

            if(animateMinMax){
                // use sin wave to modulate maxRadScale between 0 and 2
                maxRadScale = map(sin(frameCount * 0.01), -1, 1, 0, 2);
                // modulate minRadScale between 0.9 and 0
                minRadScale = map(sin(frameCount * 0.01), -1, 1, 0.9, 0);
            }else{
                // use the slider values
                maxRadScale = sliders['maxRad'].instance.value();
                minRadScale = sliders['minRad'].instance.value();
            }

            // Calculate effective radius based on 25% of the shortest window edge length
            let effectiveRadius = 0.25 * min(windowWidth, windowHeight) * effectiveRadiusScale;

            // Update each hexagon's target size based on mouse distance
            for (let hex of hexagons) {
                let d = dist(target.x, target.y, hex.x, hex.y);
                //if (d < effectiveRadius) {
                    let sizeFactor = map(d, 0, effectiveRadius, maxRadScale, minRadScale); // Scale factor: 2 at center, 1 at edge
                    hex.targetSize = hexSize * sizeFactor;
                // } else {
                //     hex.targetSize = hexSize;
                // }
            }

            // sort hexagons by distance from target (furthest should be drawn first so they're at the bottom)
            if(sortDrawOrder){
                hexagons.sort((a, b) => {
                    let distA = dist(target.x, target.y, a.x, a.y);
                    let distB = dist(target.x, target.y, b.x, b.y);
                    return reverseDrawOrder ? distA - distB : distB - distA;
                });
            }

            // Redraw hexagons and animate colors
            if (hexSize !== prevHexSize) {
                prevHexSize = hexSize;
                createHexGrid(); // Recreate grid if size changes
            }
            //animDelay = delaySlider.value();
            drawHexGrid();
            animateColors();

            if(recording){
                capturedFrames++;
                try {
                    capturer.capture( _canvas.elt );
                } catch (error) {
                    console.log(error);
                }

                //requestAnimationFrame(draw);
            }
        }

        let discardedHexes = [];


        function createHexGrid() {
            let newHexagons = [];
            let hexHeight = sqrt(3) * hexSize;
            let newCols = int(width / (1.5 * hexSize));
            let newRows = int(height / hexHeight);
            let offsetRow = floor((rows - newRows) / 2);
            let offsetCol = floor((cols - newCols) / 2);
            for (let row = 0; row < newRows; row++) {
                for (let col = 0; col < newCols; col++) {
                    let x = 1.5 * (col + offsetCol) * hexSize + hexSize;
                    let y = hexHeight * (row + offsetRow);
                    if ((col + offsetCol) % 2 === 1) {
                        y += hexHeight / 2;
                    }
                    let existingHex = hexagons.find(h => h.row === row + offsetRow && h.col === col + offsetCol);
                    if (existingHex) {
                        // If a hexagon already exists at this position, reuse it
                        existingHex.selfTargetX = x;
                        existingHex.selfTargetY = y;
                        existingHex.targetSize = hexSize;
                        newHexagons.push(existingHex);
                    } else {
                        // Otherwise, create a new hexagon
                        newHexagons.push(new Hexagon(x, y, hexSize, row + offsetRow, col + offsetCol));
                    }
                }
            }
            // If we're increasing hexSize, average the colors/sizes of the old hexagons
            if (newHexagons.length < hexagons.length) {
                let oldHexagons = hexagons.filter(h => !newHexagons.includes(h));
                for (let oldHex of oldHexagons) {
                    let nearbyNewHexes = newHexagons.filter(h => dist(h.x, h.y, oldHex.x, oldHex.y) < hexSize);
                    if (nearbyNewHexes.length > 0) {
                        let avgColor = nearbyNewHexes.reduce((acc, h) => p5.Vector.add(acc, color(h.color)), createVector(0, 0, 0)).div(nearbyNewHexes.length);
                        let avgSize = nearbyNewHexes.reduce((acc, h) => acc + h.size, 0) / nearbyNewHexes.length;
                        for (let newHex of nearbyNewHexes) {
                            newHex.color = color(avgColor.x, avgColor.y, avgColor.z);
                            newHex.size = 0;
                            newHex.targetSize = avgSize;
                        }
                    }
                }
                // we should keep a copy of the "discarded" cells so we can animate them out (let them scale to zero before removing them)
                discardedHexes = discardedHexes.concat(hexagons.filter(h => !newHexagons.includes(h)));
                for (let hex of discardedHexes) {
                    hex.targetSize = 0;
                }
            }
            hexagons = newHexagons;
            cols = newCols;
            rows = newRows;
        }

        function drawSplatForHex(hex){
            // draw a copy of the blur sprite as a shadow
            push();
            // change draw mode to center
            imageMode(CENTER);
            translate(hex.x, hex.y);
            scale(hex.size * splatScale);

            
            let TINT_HUE_QUANTIZATION = 2;
            let hue = map(hex.row, 0, rows, 0, 360);
            // push the hue foward constantly and make sure it wraps around
            hue = (hue + (frameCount * (animDelay*.1))) % 360;
            hue = Math.round(hue / TINT_HUE_QUANTIZATION) * TINT_HUE_QUANTIZATION;
            let colorKey = `${hue}`;
            if(!tintedCache[colorKey]){
                let sat = 100; // Keep saturation constant
                let bri = 100; // Keep brightness constant
                let tinted = color(hue, sat, bri);
                // Save a copy of the tinted image to avoid re-tinting
                tintedImage = createImage(blurSprite.width, blurSprite.height);

                // clone the blurSprite pixels
                tintedImage.copy(blurSprite, 0, 0, blurSprite.width, blurSprite.height, 0, 0, blurSprite.width, blurSprite.height);

                
                let d = dist(target.x, target.y, hex.x, hex.y);
                let alpha = map(d, 0, width, 255, 0); // Alpha based on distance from mouse

                tintedImage.loadPixels();
                for (let i = 0; i < tintedImage.pixels.length; i += 4) {
                    let r = tintedImage.pixels[i];
                    let g = tintedImage.pixels[i + 1];
                    let b = tintedImage.pixels[i + 2];
                    let a = tintedImage.pixels[i + 3];

                    // Blend with existing pixel value
                    tintedImage.pixels[i] = red(tinted); // R value
                    tintedImage.pixels[i + 1] = green(tinted); // G value
                    tintedImage.pixels[i + 2] = blue(tinted); // B value
                    tintedImage.pixels[i + 3] = a; // A value based on the existing A value
                }
                tintedImage.updatePixels();

                tintedCache[colorKey] = tintedImage;
            }

            // apply a random rotation to give some noise
            if(jitterSplatRotation){
                rotate(random(0, TWO_PI));
            }

            image(tintedCache[colorKey], 0, 0);
            pop();
        }

        function drawHexGrid() {
            for (let hex of hexagons) {
                hex.updateSize();
                if(drawSplats){
                    drawSplatForHex(hex)
                }
                if(drawHexes){
                    // draw the bestagon
                    hex.draw();
                }
            }
            // do the same for discardedHexes
            let toRemove = [];
            for (let hex of discardedHexes) {
                hex.updateSize();
                // if it's scaled to zero, flag for removal
                if(hex.size < 0.001){
                    toRemove.push(hex);
                }
                if(drawSplats){
                    drawSplatForHex(hex)
                }
                if(drawHexes){
                    // draw the bestagon
                    hex.draw();
                }
            }
            // remove the flagged hexes
            discardedHexes = discardedHexes.filter(h => !toRemove.includes(h));
        }

        function animateColors() {
            // if(!doAnimateColors){
            //     if(!computedColorsOnce){
            //         computedColorsOnce = 1;
            //     }else{
            //         return;
            //     }
            // };
            let maxDelay = rows * animDelay;
            if (myColorMode === COLOR_MODE_VERTICAL) { // Vertical hue shift
                for (let hex of hexagons) {
                    let delay = hex.row * animDelay;
                    let colorTime = (frameCount - delay) % maxDelay;
                    let hue = map(colorTime, 0, maxDelay, 0, 360);
                    hex.color = color(hue, 80, 100);
                }
            } else if (myColorMode === COLOR_MODE_HORIZONTAL) { // Horizontal hue shift
                maxDelay = cols * animDelay;
                for (let hex of hexagons) {
                    let delay = hex.col * animDelay;
                    let colorTime = (frameCount - delay) % maxDelay;
                    let hue = map(colorTime, 0, maxDelay, 0, 360);
                    hex.color = color(hue, 80, 100);
                }
            } else if (myColorMode === COLOR_MODE_RADIAL) { // Radial hue shift
                let maxDist = min(width, height) / 2;
                maxDelay = maxDist * animDelay;
                for (let hex of hexagons) {
                    let d = dist(target.x, target.y, hex.x, hex.y);
                    let delay = map(d, 0, maxDist, 0, maxDelay);
                    let colorTime = (frameCount - delay) % maxDelay;
                    let hue = map(colorTime, 0, maxDelay, 0, 360);
                    hex.color = color(hue, 80, 100);
                }
            } else if(myColorMode === COLOR_MODE_GREYSCALE){
                let maxDist = min(width, height) / 2;
                for (let hex of hexagons) {
                    let d = dist(target.x, target.y, hex.x, hex.y);
                    let lightness = map(d, 0, maxDist, 100, 0);
                    hex.color = color(0, 0, lightness);
                }
            } else if(myColorMode === COLOR_MODE_BLACK){
                for (let hex of hexagons) {
                    hex.color = color(0, 0, 0);
                }
            } else if(myColorMode === COLOR_MODE_MAGMA){
                let maxDist = min(width, height) / 2;
                for (let hex of hexagons) {
                    let d = dist(target.x, target.y, hex.x, hex.y);
                    if(d < 0.0001){
                        d = 0.0001;
                    }
                    // NOTE: this generates a color by interpolating between the color stops in the magmaGradient array
                    let stopPos = map(d, 0, maxDist, 0, 1);
                    let colorIndex = floor(stopPos * (magmaGradient.length - 1));
                    let nextColorIndex = min(colorIndex + 1, magmaGradient.length - 2);
                    let lerpFactor = stopPos * (magmaGradient.length - 1) - colorIndex;
                    lerpFactor = constrain(lerpFactor, 0, 1);
                    if(colorIndex < 0 || colorIndex >= magmaGradient.length || nextColorIndex < 0 || nextColorIndex >= magmaGradient.length){
                        // set to sensible defaults
                        colorIndex = magmaGradient.length - 1;
                        nextColorIndex = magmaGradient.length - 2;
                    }
                    let color1 = magmaGradient[colorIndex].color;// ?? color(0,0,0);
                    let color2 = magmaGradient[nextColorIndex].color;// ?? color(255,0,255);
                    let _color = lerpColor(color1, color2, lerpFactor);
                    // grab one of the two colors at random
                    //let _color = random() > 0.5 ? color1 : color2;

                    // Ensure we're getting integer values for our colors, no floats
                    _color.levels = _color.levels.map(Math.floor);
                    hex.color = _color;
                }
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            createHexGrid(); // Recreate grid for new window size
        }

        class Hexagon {
            constructor(x, y, size, row, col) {
                this.x = windowWidth / 2;
                this.y = windowHeight / 2;
                this.selfTargetX = x;
                this.selfTargetY = y; // Store the target position
                this.size = 0;
                this.targetSize = size; // New target size property
                this.row = row;
                this.col = col; // Store the column

                this.color = color(0); // Initial color
            }

            updateSize(){
                // Lerp the size towards the target size
                this.size = lerp(this.size, this.targetSize, LERP_FACTOR);
                this.x = lerp(this.x, this.selfTargetX, LERP_FACTOR);
                this.y = lerp(this.y, this.selfTargetY, LERP_FACTOR);
            }

            draw() {
                

                push();
                translate(this.x, this.y);
                fill(this.color);
                //stroke(0);
                noStroke();
                beginShape();
                for (let i = 0; i < TWO_PI; i += TWO_PI / 6) {
                    let x = this.size * cos(i);
                    let y = this.size * sin(i);
                    vertex(x, y);
                }
                endShape(CLOSE);
                pop();
            }
        }

    </script>
</body>

</html>