<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.8.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/peers/peerjs@1.3.1/dist/peerjs.min.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', (event) => {
        var socketIO = io('http://127.0.0.1:4001/', { transports: ['websocket', 'polling'] });
        console.warn('socketIO', socketIO)
        // connect to "testOpenAIServer" and send a prompt message
        socketIO.on('message', function(data){
          // This event listener will trigger for any type of message received from the server
          console.log("received message from server", data);
        });
        socketIO.on('connect', function(){
          console.log("connected to socket.io server");

          // don't do that on boot, it costs money!
          // socketIO.emit('prompt', "hello world");
        });
        socketIO.on('result', function(data){
          console.log("received result from server", data);
        });
        socketIO.on('upgrade', function(){
          console.log("socket.io connection upgraded");
        });
        socketIO.connect();
      });
    </script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.8.0/addons/p5.sound.min.js"></script> -->

    <script type="module">
      // TODO: make these "toggle-able" via flipping state bool
      // and let this code know when to construct/destruct the instance for rendering in the scene
      const ENABLE_FIELD_PREVIEW = true;
      const ENABLE_STAR_PREVIEW = true;
      import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.module.js';

        let _camera, scene, renderer, _cube, _sphere;
        let _stars = [];
        let flow_lattice = [];

        let _gizmo;

        // aka domready
        document.addEventListener('DOMContentLoaded', (event) => {
            // setTimeout(() => {
              // init();
              // animate();
            // }, 1000);
            function deinit(){
              document.body.removeChild( _renderer.domElement ); 
              _renderer, _scene, _camera, _cube, _sphere, _stars = null;
            }
            window.disableTHREEMode = function(){
              window.three_mode_initialized = false;
            }
            window.initTHREEMode = function(){
              window.three_mode_initialized = true;
              init(); 
              // kickstart renderer:
              animate();
            }
        });

        async function init() {
          // function waitReturnTrue(fn){
          //   return new Promise((resolve, reject) => {
          //     let interval = setInterval(() => {
          //       if(fn()){
          //         clearInterval(interval);
          //         resolve();
          //       }
          //     }, 1000);
          //   });
          // }
          // await waitReturnTrue(() => typeof noise !== "undefined");

          // init the flow lattice, a 3D array of 3D vectors
          if(ENABLE_FIELD_PREVIEW){
            for(let x = 0; x < 10; x++){
              flow_lattice[x] = [];
              for(let y = 0; y < 10; y++){
                flow_lattice[x][y] = [];
                for(let z = 0; z < 10; z++){
                  let nx = Math.random();
                  let ny = Math.random();
                  let nz = Math.random();
                  flow_lattice[x][y][z] = new THREE.Vector3(nx, ny, nz);
                }
              }
            }
          }

          // wait for this to load
          //: THREE.FresnelShader
          // while(typeof THREE.FresnelShader === "undefined"){
          //   await new Promise(resolve => setTimeout(resolve, 1000));
          //   //console.warn("waiting for THREE.FresnelShader to load")
          // }
          init_phase_2();
        }
        function init_phase_2(){
          _camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 100 );
            _camera.position.z = 2;

            scene = new THREE.Scene();

            // set Gizmo to a nesting of 3 arrows generated by 3 cynlinders and cones
            _gizmo = new THREE.Group();
            _gizmo.add(new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), 1, 0xff0000)); // Red
            _gizmo.add(new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), 1, 0x00ff00)); // Green
            _gizmo.add(new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), 1, 0x0000ff)); // Blue
            scene.add(_gizmo);


            // render arrows for each vector in the flow lattice
            if(ENABLE_FIELD_PREVIEW){
              flow_lattice.forEach((x, i) => {
                x.forEach((y, j) => {
                  y.forEach((z, k) => {
                    let arrow = new THREE.ArrowHelper(z, new THREE.Vector3(i, j, k), 0.5, 0x00ff00);
                    scene.add(arrow);
                  });
                });
              });
            }

            if(ENABLE_STAR_PREVIEW){
              // generate stars (random points in space within a sphere)
              const starsGeometry = new THREE.SphereGeometry(0.01, 32, 32);
              const starsMaterial = new THREE.MeshBasicMaterial({
                  color: 0xFFFFFF
              });
              // fill _stars array with 1000 random points
              for (let i = 0; i < 1000; i++) {
                  const starVector = new THREE.Vector3(
                      THREE.MathUtils.randFloatSpread(2),
                      THREE.MathUtils.randFloatSpread(2),
                      THREE.MathUtils.randFloatSpread(2)
                  );
                  const starSphere = new THREE.Mesh(starsGeometry, new THREE.MeshBasicMaterial({
                      color: 0xFFFFFF
                  }));
                  starSphere.castShadow = true; // Enable shadow casting by the star
                  starSphere.receiveShadow = true; // Enable shadow receiving by the star
                  starSphere.position.set(starVector.x, starVector.y, starVector.z);
                  scene.add(starSphere);
                  _stars.push(starSphere);
              }
            }

            // Add a directional light
            const light = new THREE.DirectionalLight(0xFFC0CB, 1.0);
            light.position.set(1, 1, 1);
            light.castShadow = true; // Enable shadow casting by the light
            scene.add(light);

            // add a second cross-directional light
            const light2 = new THREE.DirectionalLight(0xFFA500, 1.0);
            light2.position.set(-1, -1, -1);
            light2.target.position.set(0, 0, 0);
            light2.castShadow = true; // Enable shadow casting by the light

            const texture = new THREE.TextureLoader().load( 'res/crate.gif' );

            // Create a transparent cube
            let geometry = new THREE.BoxGeometry(1, 1, 1);
            // For the cube
            let material = new THREE.MeshPhongMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.5
            });

            _cube = new THREE.Mesh(geometry, material);
            _cube.castShadow = true; // Enable shadow casting by the cube
            _cube.receiveShadow = true; // Enable shadow receiving by the cube
            scene.add(_cube);

            // Create a solid sphere
            geometry = new THREE.SphereGeometry(0.5, 32, 32);
            material = new THREE.MeshPhongMaterial({
                color: 0xff0000
            });
            _sphere = new THREE.Mesh(geometry, material);
            _sphere.castShadow = true; // Enable shadow casting by the sphere
            _sphere.receiveShadow = true; // Enable shadow receiving by the sphere
            scene.add(_sphere);

            renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } ); // Enable transparency of the background
            renderer.setClearColor( 0x000000, 0 ); // Set clear color to black (default) and fully transparent
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.shadowMap.enabled = true; // Enable shadow mapping in the renderer
            renderer.shadowMap.enabled = true;
            light.castShadow = true;
            _cube.castShadow = true;
            _cube.receiveShadow = true;
            _sphere.castShadow = true;
            _sphere.receiveShadow = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Use PCFSoftShadowMap for softer shadows
            document.body.appendChild( renderer.domElement );
            console.warn("append renderer.domElement", renderer.domElement)
            renderer.domElement.id = "threejscanvas";

            // big plane
            const planeGeometry = new THREE.PlaneGeometry( 100, 100, 32 );
            let fresnelUniforms = {
                "mRefractionRatio": { value: 1.02 },
                "mFresnelBias": { value: 0.1 },
                "mFresnelPower": { value: 2.0 },
                "mFresnelScale": { value: 1.0 },
                "tCube": { value: null }
            };

            // let planeMaterial = new THREE.ShaderMaterial({
            //     uniforms: fresnelUniforms,
            //     // vertexShader: THREE.FresnelShader.vertexShader,
            //     // fragmentShader: THREE.FresnelShader.fragmentShader,
            //     side: THREE.DoubleSide,
            //     transparent: true
            // });
            // const plane = new THREE.Mesh( planeGeometry, planeMaterial );
            // plane.receiveShadow = true;
            // // rotate 90 on x axis
            // plane.rotation.x = Math.PI / 2;
            // scene.add( plane );

            window.addEventListener( 'resize', onWindowResize );
        }

        function onWindowResize() {

            _camera.aspect = window.innerWidth / window.innerHeight;
            _camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        let baseFrequency = 0.001; // Base frequency for the sinusoidal movement
        let phaseShift = Math.PI; // Phase shift to make the movements out of phase


        function animate() {
          if(!_camera){
            return;
          }
          
          // rotate the camera around the origin at a radius of 2
          let distanceFromCenter = Math.abs(window.innerWidth/2 - window.mouseX);
          // Re-map 0-1 in screenspace to 0-360 in rotation space
          let rotationSpace = (distanceFromCenter / window.innerWidth) * 360;
          distanceFromCenter *= (window.mouseX < window.innerWidth/2 ? 1 : -1);
          let rotationFactor = distanceFromCenter / (window.innerWidth / 2);
          rotationFactor = rotationFactor * 1e-9;
          _camera.position.x = 2 * Math.sin(Date.now() * 0.001 * rotationFactor) * (1/window.zoom);
          _camera.position.z = 2 * Math.cos(Date.now() * 0.001 * rotationFactor) * (1/window.zoom);
          //_camera.position.y = (-panY - mouseY) * 0.0001;
          
          _camera.lookAt(0, 0, 0);

          // Perturb the stars with 4D Perlin noise
          _stars.forEach(star => {
            if(typeof noise !== "undefined"){

              let factor = 0.1;
              let scale = 0.05;
              let _noise = noise(star.position.x, star.position.y, star.position.z, Date.now() * 0.0015);
              star.position.x += _noise * factor - scale;
              star.position.y += _noise * factor - scale;
              star.position.z += _noise * factor - scale;

              // set star color based on position
              star.material.color.setRGB(
                  Math.abs(star.position.x),
                  Math.abs(star.position.y),
                  Math.abs(star.position.z)
              );
            }
          });

          // update camera FOV to match "window.zoom"
          _camera.fov = window.fov; // 70 / window.zoom;

          // Sinusoidal movement for cube and sphere
          let time = Date.now() * baseFrequency;
          let distance = Math.sqrt(
              Math.pow(window.innerWidth/2 - window.mouseX, 2) +
              Math.pow(window.innerHeight/2 - window.mouseY, 2)
          );
          let speedFactor = 1; //1 - (distance / (window.innerWidth / 2));
          _cube.position.y = Math.sin(time * speedFactor);
          _sphere.position.y = Math.sin((time + phaseShift) * speedFactor);

          // move the camera based on panX and panY
          // _camera.position.x = window.panX * window.zoom * 0.01;
          // _camera.position.y = -window.panY * window.zoom * 0.01;
          // _camera.position.z = 1/window.zoom;
          
          try{
            // console.warn({renderer, scene, _camera})
            renderer.render( scene, _camera );
          }catch(e){
            console.error(e)
          }
          
          // Request the next frame at the end of the function to ensure all updates are rendered before the next frame is requested
          if(window.three_mode_initialized){
            requestAnimationFrame( animate );
          }

        }

    </script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NeatBox</title>
    <style>
    html, body {
        overscroll-behavior-x: none;
        background: #000;
        margin: 0;
        padding: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
    }
    input {
      z-index: 3;
    }
    #bg-image {
      position: fixed;
      width: 100vw;
      height: 100vh;
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      opacity: 0.3;
      z-index: 1;
      object-fit: cover;
      filter: blur(1000px);
    }
    main {
      /* backdrop-filter: blur(10px); */
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 2;
    }
    canvas {
        display: block;
        transition: filter .5s ease-in-out;
    }
    .deep-canvas {
      pointer-events: none;
      
    }
    iframe {
      transition: filter .5s ease-in-out;
    }
    canvas {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      right: 0;
      width: 100%;
      height: 100%;
    }
    #deep-canvas-1 {
      z-index: 3;
    }
    #deep-canvas-2 {
      z-index: 4;
    }
    #deep-canvas-3 {
      z-index: 5;
    }
    iframe, video {
      z-index: 999;
    }
    video {
      position: absolute;
    }
    #glcanvas {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      width: 100%;
      height: 100%;
      z-index: 998;
      box-sizing: border-box;
    }
    #glcanvas canvas {
      width: 100%;
      height: 100%;
      z-index: 998;
      /* border: 10px solid red; */
      box-sizing: border-box;
      /* top: 10px;
      left: 10px; */
    }
    #threejscanvas, #threejscanvas canvas {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      box-sizing: border-box;
    }
    #under-ui-elms {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      width: 100%;
      height: 100%;
      z-index: 9001;
    }
    #html-foreground {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      width: 100%;
      height: 100%;
      z-index: 9002;
    }
    #deep-canvas-ui {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 9003;
    }
    </style>
    <meta charset="utf-8" />

  </head>
  <body>
    <img id="bg-image" src="./res/bg-1.jpg" alt="">
    <div id="deep-canvas-1" class="deep-canvas"></div>
    <div id="deep-canvas-2" class="deep-canvas"></div>
    <div id="deep-canvas-3" class="deep-canvas"></div>
    <main id="main-canvas-context"></main>
    <div id="under-ui-elms"><!-- iFrames and stuff go here --></div>
    <div id="html-foreground"><!-- html inputs that need to go above iframes --></div>
    <div id="deep-canvas-ui"></div>
    <script>
      var script = document.createElement('script');
      script.src = "./neat.js?version=" //+ new Date().getTime();
      document.head.appendChild(script);

      // load neat-typescript.js TOO
      var script2 = document.createElement('script');
      script2.src = "./neat-typescript.js";
      document.head.appendChild(script2);
    </script>
  </body>
</html>
