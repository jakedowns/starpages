<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>WebGL Rainbow Shader</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://jakedowns.github.io/starpages/res/CCapture.all.min.js"></script>
    <style>
        body { margin: 0; background-color: #000; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <input type="file" accept="image/*" id="fileupload" />
    <script>
        function setupCapturing(){
            try{
                // Create a capturer that exports a WebM video
                var isWebMSupported = document.createElement('video').canPlayType('video/webm; codecs="vp8, vorbis"');
                var motionBlurFrames = 0;//2;
                capturer = isWebMSupported 
                ? new CCapture( { 
                    format: 'webm', 
                    motionBlurFrames,
                    verbose: false, 
                    fps: 120 
                } ) 
                : new CCapture( { 
                    format: 'png', 
                    motionBlurFrames,
                    verbose: false, 
                    framerate: 120 
                } );
            }catch(e){
                console.error('failed to create capturer',e);
            }
            window.startCapture = function(){
                if(!window.capturer){
                    console.warn("capturer not initialized");
                    return;
                }
                window.capturing = true;
                window.capturedFrames = 0;
                window.capturer.start();
                animate();
            }
            window.stopCapture = function(){
                if(!window.capturer){
                    console.warn("capturer not initialized");
                    return;
                }
                window.capturing = false;
                window.capturer.stop();
                window.capturer.save();
            }
        }
        document.addEventListener("DOMContentLoaded",()=>{
            setupCapturing();

            document.getElementById("fileupload").addEventListener("change", (e) => {
                const file = e.target.files[0];
                if (file.type.indexOf('image') === 0) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        texture.image.src = e.target.result;
                        texture.needsUpdate = true;
                    };
                    reader.readAsDataURL(file);
                }
            });
            const canvas = document.getElementById("canvas");
            const renderer = new THREE.WebGLRenderer({canvas});

            // Orthographic camera setup
            const frustumSize = 1;
            const aspect = canvas.clientWidth / canvas.clientHeight;
            const camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2, 
                frustumSize * aspect / 2, 
                frustumSize / 2, 
                frustumSize / -2, 
                1, 
                1000
            );
            camera.position.z = 2;

            const scene = new THREE.Scene();

            // Full-screen plane geometry
            const planeGeometry = new THREE.PlaneGeometry(2 * aspect, 2);

            const textureLoader = new THREE.TextureLoader();
            let rand_int_1_thru_17 = Math.floor(Math.random() * 17) + 1;
            const texture = textureLoader.load(`./res/bg_${rand_int_1_thru_17}.png`);

            // Custom Shader
            const shaderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    u_texture: { value: texture },
                    u_time: { value: 1.0 },
                    u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    // Add other uniforms here
                },
                vertexShader: `
                    void main() {
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float u_time;
                    uniform vec2 u_resolution;
                    uniform sampler2D u_texture;
                    void main() {
                        // Use the uniforms in your shader logic
                        vec2 uv = gl_FragCoord.xy / u_resolution;

                        float force = sin(uv.y * 20.0 + u_time) * 0.1;
                        
                        uv.y += sin(uv.x * 10.0 + u_time) * force;
                        uv.y += u_time * 0.05;
                        uv.y = mod(uv.y, 1.0);


                        //vec3 color = vec3(0.25 + 0.25 * sin(u_time),0.35 + 0.35 * cos(u_time), 0.5 + 0.5 * sin(u_time));
                        vec3 color = texture2D(u_texture, uv).rgb;
                        gl_FragColor = vec4(color, 1.0);
                    }
                `
            });

            // Creating and adding the plane to the scene
            const plane = new THREE.Mesh(planeGeometry, shaderMaterial);
            scene.add(plane);

            function resizeRendererToDisplaySize(renderer) {
                const canvas = renderer.domElement;
                let width = canvas.clientWidth;
                let height = canvas.clientHeight;

                // force to even dimensions for ffmpeg compatibility
                width = 2 * Math.floor(width / 2);
                height = 2 * Math.floor(height / 2);

                const needResize = canvas.width !== width || canvas.height !== height;
                if (needResize) {
                    renderer.setSize(width, height, false);
                }
                return needResize;
            }

            window.animate = function(time) {
                if (resizeRendererToDisplaySize(renderer)) {
                    const canvas = renderer.domElement;
                    // enforce dimensions of 2 for ffmpeg compatibility
                    canvas.width = 2 * Math.floor(canvas.clientWidth / 2);
                    canvas.height = 2 * Math.floor(canvas.clientHeight / 2);

                    camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    camera.updateProjectionMatrix();
                }
                
                shaderMaterial.uniforms.u_time.value = time * 0.001; // Convert time to seconds
                shaderMaterial.uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);


                renderer.render(scene, camera);

                requestAnimationFrame(animate);

                if(window.capturing){
                    window.capturer.capture(canvas);
                    window.capturedFrames++;
                    if(window.capturedFrames >= 1200){
                        window.stopCapture();
                    }
                }
            }

            requestAnimationFrame(animate);

            // when a user drops an image on the canvas, load it to our texture
            canvas.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();

                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    const file = e.dataTransfer.files[0];
                    if (file.type.indexOf('image') === 0) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            texture.image.src = e.target.result;
                            texture.needsUpdate = true;
                        };
                        reader.readAsDataURL(file);
                    }
                }
            });
            canvas.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
            
            document.addEventListener("resize",()=>{
                const canvas = document.getElementById("canvas");
                const renderer = new THREE.WebGLRenderer({canvas});
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                renderer.setSize(width, height, false);
            })
        });

    </script>
</body>
</html>
