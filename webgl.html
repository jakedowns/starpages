<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>WebGL Rainbow Shader</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://jakedowns.github.io/starpages/res/CCapture.all.min.js"></script>
    <style>
        body { margin: 0; background-color: #000; }
        canvas { width: 100%; height: 100% }
        #pasteFromClipboardPrompt {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 50px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
        #pasteFromClipboardPrompt.show {
            opacity: 1;
            pointer-events: all;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <input type="file" accept="image/*" id="fileupload" />
    <progress id="progress" value="0" max="100"></progress>
    <div id="pasteFromClipboardPrompt" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; color: #fff; opacity: 0; transition: opacity 0.5s ease-in-out;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
            <h1>Paste from clipboard?</h1>
            <p>Press <kbd>Ctrl</kbd>+<kbd>V</kbd> to paste the image from your clipboard.</p>
            <p>Press <kbd>Esc</kbd> to dismiss this message.</p>
            <button onclick="window.doPasteFromClipboard()">Tap Here</button>
        </div>
    </div>
    <button onclick="window.startCapture()">record video</button>
    <script>
        window.frame_blend_mode = "additive";
        window.do_clear_frame = false;
        window.maxFrames = 120 * 10;
        window.progress = document.getElementById("progress");
        function setupCapturing(){
            try{
                // Create a capturer that exports a WebM video
                var isWebMSupported = document.createElement('video').canPlayType('video/webm; codecs="vp8, vorbis"');
                var motionBlurFrames = 0;//2;
                capturer = isWebMSupported 
                ? new CCapture( { 
                    format: 'webm', 
                    motionBlurFrames,
                    verbose: false, 
                    fps: 120 
                } ) 
                : new CCapture( { 
                    format: 'png', 
                    motionBlurFrames,
                    verbose: false, 
                    framerate: 120 
                } );
            }catch(e){
                console.error('failed to create capturer',e);
            }
            window.startCapture = function(){
                if(!window.capturer){
                    console.warn("capturer not initialized");
                    return;
                }
                window.capturing = true;
                window.capturedFrames = 0;
                window.capturer.start();
                animate();
            }
            window.stopCapture = function(){
                if(!window.capturer){
                    console.warn("capturer not initialized");
                    return;
                }
                window.capturing = false;
                window.capturer.stop();
                window.capturer.save();
            }
        }
        document.addEventListener("DOMContentLoaded",()=>{
            setupCapturing();

            const pasteFromClipboardPrompt = document.getElementById("pasteFromClipboardPrompt");
            function showPasteFromClipboardPrompt(){
                pasteFromClipboardPrompt.classList.add("show");
                setTimeout(()=>{
                    pasteFromClipboardPrompt.classList.remove("show");
                },5000);
            }
            function hidePasteFromClipboardPrompt(){
                pasteFromClipboardPrompt.classList.remove("show");
            }
            let didShowClipboardPrompt = false;
            let clipboardCheckInterval = setInterval(async()=>{
                if(didShowClipboardPrompt){
                    return;
                }
                didShowClipboardPrompt = true;
                try{
                    const text = await navigator.clipboard.readText();
                    if(text){
                        showPasteFromClipboardPrompt();
                    }else{
                        hidePasteFromClipboardPrompt();
                        console.warn('nothing in clipboard')
                    }
                }catch(e){
                    console.error(e);
                }
            },1000);
            window.doPasteFromClipboard = function(){
                navigator.clipboard.readText().then((text)=>{
                    const file = new Blob([text], {type: 'image/png'});
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        texture.image.src = e.target.result;
                        texture.needsUpdate = true;
                    };
                    reader.readAsDataURL(file);
                });
            }

            document.addEventListener("keydown",(e)=>{
                if(e.key == "v" && (e.ctrlKey || e.metaKey)){
                    try{
                        window.doPasteFromClipboard();
                    }catch(e){
                        console.error(e);
                    }
                }
            },false);

            document.getElementById("fileupload").addEventListener("change", (e) => {
                const file = e.target.files[0];
                if (file.type.indexOf('image') === 0) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        texture.image.src = e.target.result;
                        texture.needsUpdate = true;
                    };
                    reader.readAsDataURL(file);
                }
            });
            const canvas = document.getElementById("canvas");
            const renderer = new THREE.WebGLRenderer({canvas});

            // Orthographic camera setup
            const frustumSize = 1;
            const aspect = canvas.clientWidth / canvas.clientHeight;
            const camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2, 
                frustumSize * aspect / 2, 
                frustumSize / 2, 
                frustumSize / -2, 
                1, 
                1000
            );
            camera.position.z = 2;

            const scene = new THREE.Scene();

            // Full-screen plane geometry
            const planeGeometry = new THREE.PlaneGeometry(2 * aspect, 2);

            const textureLoader = new THREE.TextureLoader();
            let rand_int_1_thru_17 = Math.floor(Math.random() * 17) + 1;
            const texture = textureLoader.load(`./res/bg_${rand_int_1_thru_17}.png`);

            // Custom Shader
            const shaderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    u_texture: { value: texture },
                    u_time: { value: 1.0 },
                    u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    // Add other uniforms here
                },
                vertexShader: `
                    void main() {
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float u_time;
                    uniform vec2 u_resolution;
                    uniform sampler2D u_texture;
                    void main() {
                        // Use the uniforms in your shader logic
                        vec2 uv = gl_FragCoord.xy / u_resolution;

                        float force = sin(uv.y * 20.0 + u_time) * 0.1;
                        
                        uv.y += sin(uv.x * 10.0 + u_time) * force;
                        uv.y += u_time * 0.05;
                        uv.y = mod(uv.y, 1.0);


                        //vec3 color = vec3(0.25 + 0.25 * sin(u_time),0.35 + 0.35 * cos(u_time), 0.5 + 0.5 * sin(u_time));
                        vec3 color = texture2D(u_texture, uv).rgb;
                        gl_FragColor = vec4(color, 1.0);
                    }
                `
            });

            // Creating and adding the plane to the scene
            const plane = new THREE.Mesh(planeGeometry, shaderMaterial);
            scene.add(plane);

            function resizeRendererToDisplaySize(renderer) {
                const canvas = renderer.domElement;
                let width = canvas.clientWidth;
                let height = canvas.clientHeight;

                // force to even dimensions for ffmpeg compatibility
                width = 2 * Math.floor(width / 2);
                height = 2 * Math.floor(height / 2);

                const needResize = canvas.width !== width || canvas.height !== height;
                if (needResize) {
                    renderer.setSize(width, height, false);
                }
                return needResize;
            }

            window.animate = function(time) {
                if (resizeRendererToDisplaySize(renderer)) {
                    const canvas = renderer.domElement;
                    // enforce dimensions of 2 for ffmpeg compatibility
                    canvas.width = 2 * Math.floor(canvas.clientWidth / 2);
                    canvas.height = 2 * Math.floor(canvas.clientHeight / 2);

                    camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    camera.updateProjectionMatrix();
                }
                
                shaderMaterial.uniforms.u_time.value = time * 0.001; // Convert time to seconds
                shaderMaterial.uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);

                if(window.do_clear_frame){
                    renderer.setClearColor(0x000000, 0);
                    renderer.clear();
                }else{
                    renderer.setClearColor(0x000000, 1);
                }

                renderer.render(scene, camera);

                requestAnimationFrame(animate);

                if(window.capturing){
                    window.capturer.capture(canvas);
                    window.capturedFrames++;
                    progress.value = (window.capturedFrames / maxFrames) * 100;
                    if(window.capturedFrames >= maxFrames){
                        window.stopCapture();
                    }
                }
            }

            requestAnimationFrame(animate);

            // when a user drops an image on the canvas, load it to our texture
            canvas.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();

                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    const file = e.dataTransfer.files[0];
                    if (file.type.indexOf('image') === 0) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            texture.image.src = e.target.result;
                            texture.needsUpdate = true;
                        };
                        reader.readAsDataURL(file);
                    }
                }
            });
            canvas.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
            
            document.addEventListener("resize",()=>{
                const canvas = document.getElementById("canvas");
                const renderer = new THREE.WebGLRenderer({canvas});
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                renderer.setSize(width, height, false);
            })
        });

    </script>
</body>
</html>
